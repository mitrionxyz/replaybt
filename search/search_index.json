{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"replaybt","text":"<p>Realistic backtesting engine for algo traders and AI agents.</p> <p>The engine owns execution \u2014 your strategy only emits signals. No look-ahead bias by default. Gap protection, adverse slippage, and fees are built in, not bolted on.</p>"},{"location":"#why-replaybt","title":"Why replaybt?","text":"<p>Most backtesting frameworks let you fill orders at the close of the bar that generated the signal. That's not how real trading works. In production, you see the bar close, compute indicators, and fill at the next bar's open \u2014 at a worse price.</p> <p>replaybt enforces this by design:</p> <ul> <li>Signals at T, fills at T+1 \u2014 the engine queues market orders and fills at the next bar's open</li> <li>Gap protection \u2014 if the open gaps past your stop, you get the open (not the stop level)</li> <li>Adverse slippage \u2014 entries fill worse, exits fill worse, always</li> <li>1-minute resolution \u2014 check stops intra-bar, not just at bar boundaries</li> </ul>"},{"location":"#features","title":"Features","text":"Category What you get Execution 4-phase loop, gap protection, adverse slippage, maker/taker fees Indicators 11 built-in (EMA, SMA, RSI, ATR, CHOP, Bollinger, MACD, Stochastic, VWAP, OBV) + multi-timeframe resampler Orders Market, limit (with timeout), stop orders, scale-in via merge Risk Breakeven stops, trailing stops, partial take profit Multi-asset Time-synchronized multi-symbol loop with portfolio-level metrics RL-ready <code>StepEngine</code> with gym-like <code>step(action)</code> / <code>reset()</code> API AI-friendly <code>DeclarativeStrategy</code> from JSON config, no Python class needed Validation Static bias auditor (11 checks), delay test, out-of-sample split Optimization Parallel parameter sweep, walk-forward, Monte Carlo Live-ready Async data providers for Hyperliquid and Lighter exchanges"},{"location":"#install","title":"Install","text":"<pre><code>pip install replaybt\n</code></pre> <p>Optional extras:</p> <pre><code>pip install replaybt[live]    # + aiohttp, websockets\npip install replaybt[plots]   # + matplotlib\npip install replaybt[data]    # + requests (exchange fetchers)\npip install replaybt[dev]     # + pytest, pytest-cov\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from replaybt import BacktestEngine, CSVProvider, Strategy, MarketOrder, Side\n\n\nclass EMACrossover(Strategy):\n    def configure(self, config):\n        self._prev_fast = self._prev_slow = None\n\n    def on_bar(self, bar, indicators, positions):\n        fast = indicators.get(\"ema_fast\")\n        slow = indicators.get(\"ema_slow\")\n        if fast is None or slow is None or self._prev_fast is None:\n            self._prev_fast, self._prev_slow = fast, slow\n            return None\n\n        crossed_up = fast &gt; slow and self._prev_fast &lt;= self._prev_slow\n        self._prev_fast, self._prev_slow = fast, slow\n\n        if not positions and crossed_up:\n            return MarketOrder(\n                side=Side.LONG,\n                take_profit_pct=0.05,\n                stop_loss_pct=0.03,\n            )\n        return None\n\n\nengine = BacktestEngine(\n    strategy=EMACrossover(),\n    data=CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n    config={\n        \"initial_equity\": 10_000,\n        \"indicators\": {\n            \"ema_fast\": {\"type\": \"ema\", \"period\": 15, \"source\": \"close\"},\n            \"ema_slow\": {\"type\": \"ema\", \"period\": 35, \"source\": \"close\"},\n        },\n    },\n)\nresults = engine.run()\nprint(results.summary())\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started \u2014 install, run your first backtest, understand the output</li> <li>Concepts \u2014 how the execution loop, signal timing, and gap protection work</li> <li>Cookbook \u2014 working recipes for common patterns</li> <li>API Reference \u2014 every class, method, and parameter</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete reference for all public classes, methods, and parameters.</p>"},{"location":"api/#module-map","title":"Module Map","text":"Module Classes Engine <code>BacktestEngine</code>, <code>MultiAssetEngine</code>, <code>StepEngine</code>, <code>ExecutionModel</code>, <code>Portfolio</code> Orders <code>Order</code>, <code>MarketOrder</code>, <code>LimitOrder</code>, <code>StopOrder</code>, <code>CancelPendingLimitsOrder</code> Data Types <code>Bar</code>, <code>Fill</code>, <code>Position</code>, <code>Trade</code>, <code>Side</code>, <code>OrderType</code>, <code>ExitReason</code>, <code>PendingOrder</code> Data Providers <code>DataProvider</code>, <code>CSVProvider</code>, <code>CachedProvider</code>, <code>BinanceProvider</code>, <code>BybitProvider</code>, <code>ReplayProvider</code> Data Validation <code>DataValidator</code>, <code>DataIssue</code>, <code>ValidatedProvider</code> Indicators <code>EMA</code>, <code>SMA</code>, <code>RSI</code>, <code>ATR</code>, <code>CHOP</code>, <code>BollingerBands</code>, <code>MACD</code>, <code>Stochastic</code>, <code>VWAP</code>, <code>OBV</code>, <code>IndicatorManager</code>, <code>Resampler</code> Strategy <code>Strategy</code>, <code>DeclarativeStrategy</code>, <code>StrategyConfig</code> Reporting <code>BacktestResults</code>, <code>MultiAssetResults</code>, <code>MonthStats</code> Validation <code>BacktestAuditor</code>, <code>Issue</code>, <code>DelayTest</code>, <code>OOSSplit</code> Optimization <code>ParameterSweep</code>, <code>SweepResults</code> Sizing <code>PositionSizer</code>, <code>FixedSizer</code>, <code>EquityPctSizer</code>, <code>RiskPctSizer</code>, <code>KellySizer</code> Analysis <code>MonteCarlo</code>, <code>WalkForward</code> Plots <code>plot_equity</code>, <code>plot_drawdown</code>, <code>plot_trades</code>, <code>plot_monthly_heatmap</code>, <code>plot_exit_breakdown</code>, <code>plot_multi_equity</code>, <code>plot_sweep_heatmap</code>"},{"location":"api/#import-paths","title":"Import Paths","text":"<p>All public classes are importable from <code>replaybt</code> directly:</p> <pre><code>from replaybt import BacktestEngine, CSVProvider, Strategy, MarketOrder, Side\n</code></pre> <p>For less common imports:</p> <pre><code>from replaybt.validation.auditor import audit_file\nfrom replaybt.validation.stress import DelayTest, OOSSplit\nfrom replaybt.optimize.sweep import ParameterSweep\nfrom replaybt.analysis.plots import plot_equity\n</code></pre>"},{"location":"api/analysis/","title":"Analysis","text":""},{"location":"api/analysis/#montecarlo","title":"MonteCarlo","text":"<p>Monte Carlo simulation for robustness analysis. Runs shuffle (permutation) and bootstrap (resampling) simulations on completed trade results.</p> <pre><code>from replaybt import MonteCarlo\n\nmc = MonteCarlo(results=backtest_results, n_simulations=1000)\nmc_result = mc.run()\nprint(mc_result.summary())\n</code></pre>"},{"location":"api/analysis/#constructor","title":"Constructor","text":"<pre><code>MonteCarlo(\n    results: BacktestResults,\n    n_simulations: int = 1000,\n)\n</code></pre>"},{"location":"api/analysis/#methods","title":"Methods","text":"Method Returns Description <code>run()</code> <code>MonteCarloResult</code> Execute simulations"},{"location":"api/analysis/#montecarloresult","title":"MonteCarloResult","text":"Field Type Description <code>n_simulations</code> <code>int</code> Simulations run <code>n_trades</code> <code>int</code> Trades in source <code>initial_equity</code> <code>float</code> Starting equity <code>shuffle_pnl_percentiles</code> <code>Dict[int, float]</code> PnL at 5/25/50/75/95th pct <code>shuffle_max_dd_mean</code> <code>float</code> Avg max drawdown <code>shuffle_max_dd_percentiles</code> <code>Dict[int, float]</code> DD at 5/50/95th pct <code>bootstrap_pnl_mean</code> <code>float</code> Expected PnL <code>bootstrap_pnl_std</code> <code>float</code> PnL std deviation <code>bootstrap_pnl_percentiles</code> <code>Dict[int, float]</code> PnL at 5/25/50/75/95th pct <code>bootstrap_max_dd_mean</code> <code>float</code> Avg max drawdown <code>bootstrap_max_dd_percentiles</code> <code>Dict[int, float]</code> DD at 5/50/95th pct <code>ruin_probability</code> <code>float</code> Probability of total loss Method Returns Description <code>summary()</code> <code>str</code> Formatted report"},{"location":"api/analysis/#walkforward","title":"WalkForward","text":"<p>Rolling walk-forward optimization. Trains on one window, tests on the next, repeats.</p> <pre><code>from replaybt import WalkForward\n\nwf = WalkForward(\n    strategy_class=MyStrategy,\n    data=data_provider,\n    base_config=config,\n    param_grid=grid,\n    n_windows=4,\n    train_pct=0.60,\n    metric=\"net_pnl\",\n    anchored=False,\n)\nresult = wf.run()\nprint(result.summary())\n</code></pre>"},{"location":"api/analysis/#constructor_1","title":"Constructor","text":"<pre><code>WalkForward(\n    strategy_class: Type[Strategy],\n    data: DataProvider,\n    base_config: dict,\n    param_grid: Dict[str, list],\n    n_windows: int = 4,\n    train_pct: float = 0.60,\n    metric: str = \"net_pnl\",\n    anchored: bool = False,\n    n_workers: Optional[int] = None,\n)\n</code></pre>"},{"location":"api/analysis/#methods_1","title":"Methods","text":"Method Returns Description <code>run()</code> <code>WalkForwardResult</code> Execute walk-forward"},{"location":"api/analysis/#walkforwardresult","title":"WalkForwardResult","text":"Field Type Description <code>windows</code> <code>List[WindowResult]</code> Per-window results <code>n_windows</code> <code>int</code> Number of windows <code>anchored</code> <code>bool</code> Anchored mode <code>train_pct</code> <code>float</code> Train fraction <code>metric</code> <code>str</code> Optimization metric <code>oos_net_pnl</code> <code>float</code> Combined OOS PnL <code>oos_total_trades</code> <code>int</code> Combined OOS trades <code>oos_win_rate</code> <code>float</code> Combined OOS win rate <code>oos_max_drawdown_pct</code> <code>float</code> Combined OOS drawdown <code>param_stability</code> <code>Dict[str, List]</code> Params per window Property Type Description <code>params_consistent</code> <code>bool</code> Same params &gt;50% of windows Method Returns Description <code>summary()</code> <code>str</code> Formatted report"},{"location":"api/analysis/#windowresult","title":"WindowResult","text":"Field Type Description <code>window_index</code> <code>int</code> Window number <code>train_start_idx</code> <code>int</code> Train start index <code>train_end_idx</code> <code>int</code> Train end index <code>test_start_idx</code> <code>int</code> Test start index <code>test_end_idx</code> <code>int</code> Test end index <code>best_params</code> <code>dict</code> Best params from train <code>train_metrics</code> <code>dict</code> Training metrics <code>test_result</code> <code>BacktestResults</code> OOS test results <code>all_combos</code> <code>int</code> Combos evaluated"},{"location":"api/data-providers/","title":"Data Providers","text":""},{"location":"api/data-providers/#dataprovider-abc","title":"DataProvider (ABC)","text":"<p>Abstract base for all data providers. Implement <code>__iter__</code>, <code>symbol</code>, and <code>timeframe</code>.</p> <pre><code>from replaybt import DataProvider, Bar\n\nclass MyProvider(DataProvider):\n    def __iter__(self):\n        yield Bar(...)\n\n    def symbol(self):\n        return \"MY_ASSET\"\n\n    def timeframe(self):\n        return \"1m\"\n\n    def reset(self):\n        pass  # optional: reset to beginning\n</code></pre>"},{"location":"api/data-providers/#abstract-methods","title":"Abstract Methods","text":"Method Returns Description <code>__iter__()</code> <code>Iterator[Bar]</code> Yield bars chronologically <code>symbol()</code> <code>str</code> Asset symbol <code>timeframe()</code> <code>str</code> Base timeframe"},{"location":"api/data-providers/#optional-methods","title":"Optional Methods","text":"Method Returns Description <code>reset()</code> <code>None</code> Reset to beginning"},{"location":"api/data-providers/#csvprovider","title":"CSVProvider","text":"<p>Load OHLCV data from CSV or Parquet files.</p> <pre><code>from replaybt import CSVProvider\n\ndata = CSVProvider(\n    path=\"ETH_1m.csv\",\n    symbol_name=\"ETH\",\n    timeframe=\"1m\",\n    start=\"2024-01-01\",\n    end=\"2024-12-31\",\n    timestamp_col=\"timestamp\",\n)\n</code></pre> Parameter Type Default Description <code>path</code> <code>str \\| Path</code> required File path (CSV or Parquet) <code>symbol_name</code> <code>str</code> <code>\"\"</code> Symbol name for Bar objects <code>timeframe</code> <code>str</code> <code>\"1m\"</code> Bar timeframe <code>start</code> <code>Optional[str]</code> <code>None</code> Start date filter <code>end</code> <code>Optional[str]</code> <code>None</code> End date filter <code>timestamp_col</code> <code>str</code> <code>\"timestamp\"</code> Timestamp column name"},{"location":"api/data-providers/#cachedprovider","title":"CachedProvider","text":"<p>Wraps any provider. Caches bars in memory after first iteration.</p> <pre><code>from replaybt import CachedProvider\n\ndata = CachedProvider(CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"))\n</code></pre>"},{"location":"api/data-providers/#binanceprovider","title":"BinanceProvider","text":"<p>Fetch historical data from Binance API. Requires <code>pip install replaybt[data]</code>.</p> <pre><code>from replaybt import BinanceProvider\n\ndata = BinanceProvider(\n    symbol=\"ETHUSDT\",\n    timeframe=\"1m\",\n    start=\"2024-01-01\",\n    end=\"2024-12-31\",\n)\n</code></pre> Parameter Type Default Description <code>symbol</code> <code>str</code> required Trading pair <code>timeframe</code> <code>str</code> <code>\"1m\"</code> Bar timeframe <code>start</code> <code>Optional[str]</code> <code>None</code> Start date <code>end</code> <code>Optional[str]</code> <code>None</code> End date"},{"location":"api/data-providers/#bybitprovider","title":"BybitProvider","text":"<p>Fetch historical data from Bybit API. Requires <code>pip install replaybt[data]</code>.</p> <pre><code>from replaybt import BybitProvider\n\ndata = BybitProvider(\n    symbol=\"ETHUSDT\",\n    timeframe=\"1m\",\n    start=\"2024-01-01\",\n    end=\"2024-12-31\",\n)\n</code></pre> <p>Same parameters as <code>BinanceProvider</code>.</p>"},{"location":"api/data-providers/#replayprovider","title":"ReplayProvider","text":"<p>Wraps any provider. Adds <code>time.sleep()</code> between bars for Nx speed replay.</p> <pre><code>from replaybt import ReplayProvider\n\ndata = ReplayProvider(\n    inner=CSVProvider(\"ETH_1m.csv\"),\n    speed=60,       # 60x speed\n    on_bar=None,    # optional callback\n)\n</code></pre> Parameter Type Default Description <code>inner</code> <code>DataProvider</code> required Wrapped provider <code>speed</code> <code>float</code> <code>60</code> Replay speed multiplier <code>on_bar</code> <code>Optional[Callable[[Bar], None]]</code> <code>None</code> Per-bar callback"},{"location":"api/data-providers/#asyncdataprovider","title":"AsyncDataProvider","text":"<p>Base class for async live data providers.</p>"},{"location":"api/data-providers/#hyperliquidprovider","title":"HyperliquidProvider","text":"<p>Real-time data from Hyperliquid exchange. Requires <code>pip install replaybt[live]</code>.</p>"},{"location":"api/data-providers/#lighterprovider","title":"LighterProvider","text":"<p>Real-time data from Lighter exchange. Requires <code>pip install replaybt[live]</code>.</p>"},{"location":"api/data-types/","title":"Data Types","text":""},{"location":"api/data-types/#bar","title":"Bar","text":"<p>A single OHLCV candle. Frozen dataclass (immutable).</p> <pre><code>from replaybt import Bar\n\nbar = Bar(\n    timestamp=datetime(2024, 1, 1, 0, 0),\n    open=2300.50,\n    high=2301.20,\n    low=2299.80,\n    close=2300.90,\n    volume=125.5,\n    symbol=\"ETH\",\n    timeframe=\"1m\",\n)\n</code></pre> Field Type Default Description <code>timestamp</code> <code>datetime</code> required Bar open time <code>open</code> <code>float</code> required Open price <code>high</code> <code>float</code> required High price <code>low</code> <code>float</code> required Low price <code>close</code> <code>float</code> required Close price <code>volume</code> <code>float</code> required Volume <code>symbol</code> <code>str</code> <code>\"\"</code> Asset symbol <code>timeframe</code> <code>str</code> <code>\"1m\"</code> Bar timeframe"},{"location":"api/data-types/#side","title":"Side","text":"<p>Trade direction.</p> <pre><code>from replaybt import Side\n\nSide.LONG   # \"LONG\"\nSide.SHORT  # \"SHORT\"\n</code></pre>"},{"location":"api/data-types/#ordertype","title":"OrderType","text":"<pre><code>from replaybt import OrderType\n\nOrderType.MARKET  # \"MARKET\"\nOrderType.LIMIT   # \"LIMIT\"\nOrderType.STOP    # \"STOP\"\n</code></pre>"},{"location":"api/data-types/#exitreason","title":"ExitReason","text":"<pre><code>from replaybt import ExitReason\n\nExitReason.STOP_LOSS          # \"STOP_LOSS\"\nExitReason.STOP_LOSS_GAP      # \"STOP_LOSS_GAP\"\nExitReason.TAKE_PROFIT        # \"TAKE_PROFIT\"\nExitReason.TAKE_PROFIT_GAP    # \"TAKE_PROFIT_GAP\"\nExitReason.BREAKEVEN          # \"BREAKEVEN\"\nExitReason.BREAKEVEN_GAP      # \"BREAKEVEN_GAP\"\nExitReason.TRAILING_STOP      # \"TRAILING_STOP\"\nExitReason.TRAILING_STOP_GAP  # \"TRAILING_STOP_GAP\"\nExitReason.PARTIAL_TP         # \"PARTIAL_TP\"\nExitReason.SIGNAL             # \"SIGNAL\"\n</code></pre>"},{"location":"api/data-types/#fill","title":"Fill","text":"<p>An order fill event. Frozen dataclass.</p> <pre><code>from replaybt import Fill\n</code></pre> Field Type Default Description <code>timestamp</code> <code>datetime</code> required Fill time <code>side</code> <code>Side</code> required LONG or SHORT <code>price</code> <code>float</code> required Fill price (after slippage) <code>size_usd</code> <code>float</code> required Position size in USD <code>symbol</code> <code>str</code> <code>\"\"</code> Asset symbol <code>fees</code> <code>float</code> <code>0.0</code> Fees paid <code>slippage_cost</code> <code>float</code> <code>0.0</code> Slippage cost <code>is_entry</code> <code>bool</code> <code>True</code> True for entries, False for exits <code>reason</code> <code>str</code> <code>\"\"</code> Exit reason (empty for entries)"},{"location":"api/data-types/#position","title":"Position","text":"<p>An open position. Mutable dataclass.</p> Field Type Default Description <code>side</code> <code>Side</code> required LONG or SHORT <code>entry_price</code> <code>float</code> required Average entry price <code>entry_time</code> <code>datetime</code> required Entry timestamp <code>size_usd</code> <code>float</code> required Position size <code>stop_loss</code> <code>float</code> required Current SL price <code>take_profit</code> <code>float</code> required Current TP price <code>symbol</code> <code>str</code> <code>\"\"</code> Asset symbol <code>breakeven_activated</code> <code>bool</code> <code>False</code> Breakeven active <code>breakeven_trigger</code> <code>float</code> <code>0.0</code> Breakeven trigger price <code>breakeven_lock</code> <code>float</code> <code>0.0</code> Breakeven lock price <code>trailing_stop_pct</code> <code>float</code> <code>0.0</code> Trail distance <code>trailing_stop_activation_pct</code> <code>float</code> <code>0.0</code> Trail activation <code>position_high</code> <code>float</code> <code>0.0</code> Highest price since entry <code>position_low</code> <code>float</code> <code>0.0</code> Lowest price since entry <code>trailing_stop_activated</code> <code>bool</code> <code>False</code> Trail active <code>partial_tp_pct</code> <code>float</code> <code>0.0</code> Partial TP fraction <code>partial_tp_new_tp_pct</code> <code>float</code> <code>0.0</code> New TP after partial <code>partial_tp_done</code> <code>bool</code> <code>False</code> Partial TP executed <code>group</code> <code>Optional[str]</code> <code>None</code> Position group"},{"location":"api/data-types/#properties","title":"Properties","text":"Property Type Description <code>is_long</code> <code>bool</code> True if LONG side"},{"location":"api/data-types/#trade","title":"Trade","text":"<p>A completed trade (entry + exit). Frozen dataclass.</p> Field Type Default Description <code>entry_time</code> <code>datetime</code> required Entry timestamp <code>exit_time</code> <code>datetime</code> required Exit timestamp <code>side</code> <code>Side</code> required LONG or SHORT <code>entry_price</code> <code>float</code> required Entry price <code>exit_price</code> <code>float</code> required Exit price <code>size_usd</code> <code>float</code> required Position size <code>pnl_usd</code> <code>float</code> required Profit/loss in USD <code>pnl_pct</code> <code>float</code> required Profit/loss as fraction <code>fees</code> <code>float</code> required Total fees (entry + exit) <code>reason</code> <code>str</code> required Exit reason <code>symbol</code> <code>str</code> <code>\"\"</code> Asset symbol <code>is_partial</code> <code>bool</code> <code>False</code> Partial close <code>group</code> <code>Optional[str]</code> <code>None</code> Position group"},{"location":"api/data-types/#pendingorder","title":"PendingOrder","text":"<p>Internal representation of a queued order.</p> Field Type Default Description <code>side</code> <code>Side</code> required Direction <code>order_type</code> <code>OrderType</code> <code>MARKET</code> Order type <code>limit_price</code> <code>Optional[float]</code> <code>None</code> Limit fill price <code>size_usd</code> <code>Optional[float]</code> <code>None</code> Position size <code>stop_loss_pct</code> <code>Optional[float]</code> <code>None</code> SL percentage <code>take_profit_pct</code> <code>Optional[float]</code> <code>None</code> TP percentage <code>symbol</code> <code>str</code> <code>\"\"</code> Asset symbol <code>bars_elapsed</code> <code>int</code> <code>0</code> Bars since placed <code>max_bars</code> <code>int</code> <code>0</code> Timeout (0 = never)"},{"location":"api/data-validation/","title":"Data Validation","text":""},{"location":"api/data-validation/#datavalidator","title":"DataValidator","text":"<p>Validates OHLCV DataFrames for quality issues.</p> <pre><code>from replaybt import DataValidator\n\nvalidator = DataValidator(df, symbol=\"ETH\", timeframe=\"1m\")\nissues = validator.validate()\nprint(validator.report())\n</code></pre>"},{"location":"api/data-validation/#constructor","title":"Constructor","text":"<pre><code>DataValidator(\n    df: pd.DataFrame,\n    symbol: str = \"\",\n    timeframe: str = \"1m\",\n)\n</code></pre>"},{"location":"api/data-validation/#methods","title":"Methods","text":"Method Returns Description <code>validate()</code> <code>List[DataIssue]</code> Run all checks <code>report()</code> <code>str</code> Formatted report"},{"location":"api/data-validation/#checks","title":"Checks","text":"Check Severity Description Missing columns ERROR OHLCV columns not present Duplicate timestamps ERROR Same timestamp twice Time gaps WARNING Missing bars OHLC violations WARNING High &lt; Low, etc. Negative values ERROR Negative prices/volume Zero values WARNING Zero prices"},{"location":"api/data-validation/#dataissue","title":"DataIssue","text":"<p>A single data quality issue.</p> Field Type Description <code>severity</code> <code>str</code> <code>\"ERROR\"</code>, <code>\"WARNING\"</code>, <code>\"INFO\"</code> <code>check</code> <code>str</code> Issue type identifier <code>message</code> <code>str</code> Human-readable description <code>row_index</code> <code>Optional[int]</code> Row where issue occurs <code>timestamp</code> <code>Optional[datetime]</code> Timestamp of the row"},{"location":"api/data-validation/#validatedprovider","title":"ValidatedProvider","text":"<p>Wraps a provider and validates bars on the fly.</p> <pre><code>from replaybt import ValidatedProvider\n\ndata = ValidatedProvider(\n    inner=CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n    stop_on_error=False,\n)\n</code></pre> Parameter Type Default Description <code>inner</code> <code>DataProvider</code> required Provider to validate <code>symbol</code> <code>str</code> <code>\"\"</code> Symbol name <code>timeframe</code> <code>str</code> <code>\"1m\"</code> Expected timeframe <code>stop_on_error</code> <code>bool</code> <code>False</code> Raise on first ERROR"},{"location":"api/data-validation/#convenience-functions","title":"Convenience Functions","text":"<pre><code>from replaybt import validate_dataframe, validate_provider\n\n# Validate DataFrame\nissues = validate_dataframe(df, symbol=\"ETH\", timeframe=\"1m\")\n\n# Validate provider\nissues = validate_provider(my_provider, symbol=\"ETH\")\n</code></pre>"},{"location":"api/engine/","title":"Engine","text":""},{"location":"api/engine/#backtestengine","title":"BacktestEngine","text":"<p>Main backtest runner. Takes a strategy, data provider, and config; returns <code>BacktestResults</code>.</p> <pre><code>from replaybt import BacktestEngine\n\nengine = BacktestEngine(\n    strategy=my_strategy,\n    data=my_data,\n    config={...},\n)\nresults = engine.run()\n</code></pre>"},{"location":"api/engine/#constructor","title":"Constructor","text":"<pre><code>BacktestEngine(\n    strategy: Strategy,\n    data: DataProvider,\n    config: Optional[Dict] = None,\n)\n</code></pre>"},{"location":"api/engine/#config-keys","title":"Config Keys","text":"Key Type Default Description <code>initial_equity</code> <code>float</code> <code>10000</code> Starting capital <code>default_size_usd</code> <code>float</code> <code>10000</code> Default position size in USD <code>max_positions</code> <code>int</code> <code>1</code> Maximum concurrent positions <code>slippage</code> <code>float</code> <code>0.0002</code> Per-side slippage (0.02%) <code>taker_fee</code> <code>float</code> <code>0.00015</code> Per-side taker fee (0.015%) <code>maker_fee</code> <code>float</code> <code>0.0</code> Per-side maker fee <code>indicators</code> <code>Dict</code> <code>{}</code> Indicator configurations <code>skip_signal_on_close</code> <code>bool</code> <code>True</code> Skip <code>on_bar</code> when position closes <code>same_direction_only</code> <code>bool</code> <code>True</code> Reject opposite-direction orders <code>sizer</code> <code>PositionSizer</code> <code>None</code> Custom position sizer"},{"location":"api/engine/#methods","title":"Methods","text":"Method Returns Description <code>run()</code> <code>BacktestResults</code> Execute backtest <code>on(event, callback)</code> <code>None</code> Register event listener <code>remove_listener(event, callback)</code> <code>None</code> Remove event listener"},{"location":"api/engine/#events","title":"Events","text":"Event Callback Signature When <code>\"bar\"</code> <code>(bar: Bar)</code> Every bar <code>\"fill\"</code> <code>(fill: Fill)</code> Order fills <code>\"exit\"</code> <code>(fill: Fill, trade: Trade)</code> Position closes <code>\"signal\"</code> <code>(order: Order)</code> Signal emitted"},{"location":"api/engine/#multiassetengine","title":"MultiAssetEngine","text":"<p>Multi-symbol runner with time-synchronized bar processing and portfolio-level metrics.</p> <pre><code>from replaybt import MultiAssetEngine\n\nengine = MultiAssetEngine(\n    strategy=my_strategy,\n    assets={\"ETH\": eth_data, \"SOL\": sol_data},\n    config={...},\n)\nresults = engine.run()  # -&gt; MultiAssetResults\n</code></pre>"},{"location":"api/engine/#constructor_1","title":"Constructor","text":"<pre><code>MultiAssetEngine(\n    strategy: Strategy,\n    assets: Dict[str, DataProvider],\n    config: Optional[Dict] = None,\n)\n</code></pre>"},{"location":"api/engine/#additional-config-keys","title":"Additional Config Keys","text":"Key Type Default Description <code>symbol_configs</code> <code>Dict[str, Dict]</code> <code>{}</code> Per-symbol config overrides <code>max_total_exposure_usd</code> <code>float</code> <code>None</code> Portfolio-level exposure cap"},{"location":"api/engine/#methods_1","title":"Methods","text":"Method Returns Description <code>run()</code> <code>MultiAssetResults</code> Execute multi-asset backtest"},{"location":"api/engine/#stepengine","title":"StepEngine","text":"<p>Gym-like step/reset interface for RL agents.</p> <pre><code>from replaybt import StepEngine\n\nenv = StepEngine(data=my_data, config={...})\nobs = env.reset()\nwhile not obs.done:\n    result = env.step(action)\n    obs = result.observation\n</code></pre>"},{"location":"api/engine/#constructor_2","title":"Constructor","text":"<pre><code>StepEngine(\n    data: DataProvider,\n    config: Optional[Dict] = None,\n    strategy: Optional[Strategy] = None,\n)\n</code></pre>"},{"location":"api/engine/#methods_2","title":"Methods","text":"Method Returns Description <code>reset()</code> <code>StepObservation</code> Start new episode <code>step(action)</code> <code>StepResult</code> Process one bar <code>done()</code> <code>bool</code> Episode finished? <code>close()</code> <code>None</code> Cleanup"},{"location":"api/engine/#stepobservation","title":"StepObservation","text":"Field Type Description <code>bar</code> <code>Bar</code> Current bar <code>indicators</code> <code>Dict[str, Any]</code> Indicator values <code>positions</code> <code>List[Position]</code> Open positions <code>equity</code> <code>float</code> Current equity <code>step_count</code> <code>int</code> Steps taken <code>done</code> <code>bool</code> Episode finished"},{"location":"api/engine/#stepresult","title":"StepResult","text":"Field Type Description <code>observation</code> <code>StepObservation</code> Next state <code>reward</code> <code>float</code> PnL change this step <code>done</code> <code>bool</code> Episode finished <code>info</code> <code>Dict[str, Any]</code> Metadata"},{"location":"api/engine/#executionmodel","title":"ExecutionModel","text":"<p>Handles slippage, fees, and gap protection.</p>"},{"location":"api/engine/#constructor_3","title":"Constructor","text":"<pre><code>ExecutionModel(\n    slippage: float = 0.0002,\n    taker_fee: float = 0.00015,\n    maker_fee: float = 0.0,\n)\n</code></pre>"},{"location":"api/engine/#methods_3","title":"Methods","text":"Method Returns Description <code>apply_entry_slippage(price, side)</code> <code>float</code> Adverse entry slippage <code>apply_exit_slippage(price, side)</code> <code>float</code> Adverse exit slippage <code>calc_fees(size_usd, is_maker)</code> <code>float</code> Fee for one side <code>check_exit(pos, bar)</code> <code>Tuple[Optional[float], Optional[str]]</code> Check if position should exit"},{"location":"api/engine/#portfolio","title":"Portfolio","text":"<p>Tracks positions, equity, trades, and drawdown.</p>"},{"location":"api/engine/#constructor_4","title":"Constructor","text":"<pre><code>Portfolio(\n    initial_equity: float = 10_000.0,\n    default_size_usd: float = 10_000.0,\n    execution: Optional[ExecutionModel] = None,\n    max_positions: int = 1,\n    sizer: Optional[PositionSizer] = None,\n)\n</code></pre>"},{"location":"api/engine/#properties","title":"Properties","text":"Property Type Description <code>has_position</code> <code>bool</code> Any open positions <code>position</code> <code>Optional[Position]</code> First position <code>position_count</code> <code>int</code> Number of open positions <code>equity</code> <code>float</code> Current equity <code>peak_equity</code> <code>float</code> Peak equity seen <code>max_drawdown</code> <code>float</code> Max drawdown ratio <code>positions</code> <code>List[Position]</code> Open positions <code>trades</code> <code>List[Trade]</code> Closed trades <code>fills</code> <code>List[Fill]</code> All fills <code>total_fees</code> <code>float</code> Cumulative fees <code>equity_curve</code> <code>List[Tuple[datetime, float]]</code> Equity after each trade"},{"location":"api/engine/#methods_4","title":"Methods","text":"Method Returns Description <code>can_open(group)</code> <code>bool</code> Can open new position <code>positions_in_group(group)</code> <code>List[Position]</code> Positions in group <code>open_position(bar, order, ...)</code> <code>Fill</code> Open position <code>merge_position(idx, bar, limit_price, ...)</code> <code>Fill</code> Merge into existing position <code>close_position(idx, price, reason, ...)</code> <code>Trade</code> Close position <code>partial_close_position(idx, pct, price, ...)</code> <code>Trade</code> Close fraction"},{"location":"api/indicators/","title":"Indicators","text":""},{"location":"api/indicators/#indicatormanager","title":"IndicatorManager","text":"<p>Manages multiple indicators with automatic multi-timeframe resampling.</p> <pre><code>from replaybt import IndicatorManager\n\nmanager = IndicatorManager({\n    \"ema_fast\": {\"type\": \"ema\", \"period\": 15, \"timeframe\": \"30m\", \"source\": \"close\"},\n    \"rsi_7\":   {\"type\": \"rsi\", \"period\": 7, \"method\": \"wilder\"},\n    \"atr_14\":  {\"type\": \"atr\", \"period\": 14, \"timeframe\": \"1h\"},\n})\n</code></pre>"},{"location":"api/indicators/#methods","title":"Methods","text":"Method Returns Description <code>update(bar)</code> <code>None</code> Feed a 1m bar <code>get(name)</code> <code>Any</code> Get indicator value <code>all()</code> <code>Dict[str, Any]</code> All values as dict <code>ready()</code> <code>bool</code> All indicators ready <code>reset()</code> <code>None</code> Reset all state"},{"location":"api/indicators/#indicator-abc","title":"Indicator (ABC)","text":"<p>Base class for all indicators.</p>"},{"location":"api/indicators/#constructor","title":"Constructor","text":"<pre><code>Indicator(name: str, period: int = 14)\n</code></pre>"},{"location":"api/indicators/#methods_1","title":"Methods","text":"Method Returns Description <code>update(bar)</code> <code>None</code> Process completed bar <code>value()</code> <code>Any</code> Current value <code>reset()</code> <code>None</code> Reset state"},{"location":"api/indicators/#properties","title":"Properties","text":"Property Type Description <code>ready</code> <code>bool</code> Enough data for valid output"},{"location":"api/indicators/#static-methods","title":"Static Methods","text":"Method Returns Description <code>batch_ema(series, period)</code> <code>Series</code> EMA on pandas Series <code>batch_rsi_wilder(closes, period)</code> <code>Series</code> Wilder's RSI <code>batch_rsi_simple(closes, period)</code> <code>Series</code> Simple RSI"},{"location":"api/indicators/#ema","title":"EMA","text":"<p>Exponential Moving Average.</p> <pre><code>{\"type\": \"ema\", \"period\": 15, \"source\": \"close\", \"timeframe\": \"30m\"}\n</code></pre> Param Type Default Description <code>period</code> <code>int</code> <code>14</code> EMA window <code>source</code> <code>str</code> <code>\"close\"</code> Price field (<code>close</code>, <code>open</code>, <code>high</code>, <code>low</code>) <code>timeframe</code> <code>str</code> <code>\"1m\"</code> Bar timeframe <p>Value: <code>Optional[float]</code></p>"},{"location":"api/indicators/#sma","title":"SMA","text":"<p>Simple Moving Average.</p> <pre><code>{\"type\": \"sma\", \"period\": 14, \"source\": \"close\", \"timeframe\": \"30m\"}\n</code></pre> <p>Same parameters as EMA. Value: <code>Optional[float]</code></p>"},{"location":"api/indicators/#rsi","title":"RSI","text":"<p>Relative Strength Index. Supports Wilder's exponential or simple rolling.</p> <pre><code>{\"type\": \"rsi\", \"period\": 7, \"method\": \"wilder\", \"source\": \"close\", \"timeframe\": \"30m\"}\n</code></pre> Param Type Default Description <code>period</code> <code>int</code> <code>14</code> RSI window <code>method</code> <code>str</code> <code>\"wilder\"</code> <code>\"wilder\"</code> (exponential) or <code>\"simple\"</code> (rolling) <code>source</code> <code>str</code> <code>\"close\"</code> Price field <code>timeframe</code> <code>str</code> <code>\"1m\"</code> Bar timeframe <p>Value: <code>Optional[float]</code> (0-100)</p>"},{"location":"api/indicators/#atr","title":"ATR","text":"<p>Average True Range.</p> <pre><code>{\"type\": \"atr\", \"period\": 14, \"mode\": \"sma\", \"timeframe\": \"1h\"}\n</code></pre> Param Type Default Description <code>period</code> <code>int</code> <code>14</code> ATR window <code>mode</code> <code>str</code> <code>\"sma\"</code> <code>\"sma\"</code> or <code>\"wilder\"</code> <code>timeframe</code> <code>str</code> <code>\"1m\"</code> Bar timeframe <p>Value: <code>Optional[float]</code></p>"},{"location":"api/indicators/#chop","title":"CHOP","text":"<p>Choppiness Index. High values = choppy/ranging, low values = trending.</p> <pre><code>{\"type\": \"chop\", \"period\": 14, \"atr_mode\": \"sma\", \"timeframe\": \"1h\"}\n</code></pre> Param Type Default Description <code>period</code> <code>int</code> <code>14</code> Window <code>atr_mode</code> <code>str</code> <code>\"sma\"</code> ATR calculation mode <code>timeframe</code> <code>str</code> <code>\"1m\"</code> Bar timeframe <p>Value: <code>Optional[float]</code> (expressed as ATR/Close ratio)</p>"},{"location":"api/indicators/#bollingerbands","title":"BollingerBands","text":"<p>Upper, middle, lower bands + bandwidth + %B.</p> <pre><code>{\"type\": \"bollinger\", \"period\": 20, \"num_std\": 2.0, \"source\": \"close\"}\n</code></pre> Param Type Default Description <code>period</code> <code>int</code> <code>20</code> SMA window <code>num_std</code> <code>float</code> <code>2.0</code> Standard deviation multiplier <code>source</code> <code>str</code> <code>\"close\"</code> Price field <code>timeframe</code> <code>str</code> <code>\"1m\"</code> Bar timeframe <p>Value: <code>Optional[Dict[str, float]]</code> with keys: <code>upper</code>, <code>middle</code>, <code>lower</code>, <code>bandwidth</code>, <code>pct_b</code></p>"},{"location":"api/indicators/#macd","title":"MACD","text":"<p>Moving Average Convergence Divergence.</p> <pre><code>{\"type\": \"macd\", \"fast_period\": 12, \"slow_period\": 26, \"signal_period\": 9, \"source\": \"close\"}\n</code></pre> Param Type Default Description <code>fast_period</code> <code>int</code> <code>12</code> Fast EMA period <code>slow_period</code> <code>int</code> <code>26</code> Slow EMA period <code>signal_period</code> <code>int</code> <code>9</code> Signal line period <code>source</code> <code>str</code> <code>\"close\"</code> Price field <code>timeframe</code> <code>str</code> <code>\"1m\"</code> Bar timeframe <p>Value: <code>Optional[Dict[str, float]]</code> with keys: <code>macd</code>, <code>signal</code>, <code>histogram</code></p>"},{"location":"api/indicators/#stochastic","title":"Stochastic","text":"<p>Stochastic Oscillator (%K and %D).</p> <pre><code>{\"type\": \"stochastic\", \"k_period\": 14, \"d_period\": 3, \"smooth_k\": 3}\n</code></pre> Param Type Default Description <code>k_period</code> <code>int</code> <code>14</code> %K lookback <code>d_period</code> <code>int</code> <code>3</code> %D smoothing <code>smooth_k</code> <code>int</code> <code>3</code> %K smoothing (1 = fast stochastic) <code>timeframe</code> <code>str</code> <code>\"1m\"</code> Bar timeframe <p>Value: <code>Optional[Dict[str, float]]</code> with keys: <code>k</code>, <code>d</code></p>"},{"location":"api/indicators/#vwap","title":"VWAP","text":"<p>Volume-Weighted Average Price. Resets daily at midnight UTC.</p> <pre><code>{\"type\": \"vwap\"}\n</code></pre> <p>Value: <code>Optional[float]</code></p>"},{"location":"api/indicators/#obv","title":"OBV","text":"<p>On-Balance Volume. Running sum: +volume on up bars, -volume on down bars.</p> <pre><code>{\"type\": \"obv\"}\n</code></pre> <p>Value: <code>float</code></p>"},{"location":"api/indicators/#resampler","title":"Resampler","text":"<p>Batch resampling utilities for DataFrame-based workflows.</p>"},{"location":"api/indicators/#static-methods_1","title":"Static Methods","text":"<pre><code>from replaybt import Resampler\n\n# Resample 1m DataFrame to higher timeframe\ndf_30m = Resampler.resample(df_1m, \"30m\")\n\n# Add indicators\ndf = Resampler.add_ema(df, period=15, col=\"close\", name=\"ema_15\")\ndf = Resampler.add_rsi_wilder(df, period=14, col=\"close\", name=\"rsi_14\")\ndf = Resampler.add_rsi_simple(df, period=14, col=\"close\", name=\"rsi_14_simple\")\ndf = Resampler.add_chop(df, period=14, name=\"chop_14\")\n</code></pre> Method Description <code>resample(df, timeframe)</code> Resample to <code>\"5m\"</code>, <code>\"15m\"</code>, <code>\"30m\"</code>, <code>\"1h\"</code>, <code>\"2h\"</code>, <code>\"4h\"</code>, <code>\"1d\"</code> <code>add_ema(df, period, col, name)</code> Add EMA column <code>add_rsi_wilder(df, period, col, name)</code> Add Wilder's RSI column <code>add_rsi_simple(df, period, col, name)</code> Add Simple RSI column <code>add_chop(df, period, name)</code> Add CHOP column"},{"location":"api/optimization/","title":"Optimization","text":""},{"location":"api/optimization/#parametersweep","title":"ParameterSweep","text":"<p>Parallel grid search using multiprocessing.</p> <pre><code>from replaybt.optimize.sweep import ParameterSweep\n\nsweep = ParameterSweep(\n    strategy_class=MyStrategy,\n    data=CSVProvider(\"ETH_1m.csv\"),\n    base_config={\"initial_equity\": 10_000},\n    param_grid={\n        \"take_profit_pct\": [0.04, 0.06, 0.08],\n        \"stop_loss_pct\": [0.02, 0.03, 0.04],\n    },\n    n_workers=10,\n)\nresults = sweep.run()\n</code></pre>"},{"location":"api/optimization/#constructor","title":"Constructor","text":"<pre><code>ParameterSweep(\n    strategy_class: Type[Strategy],\n    data: DataProvider,\n    base_config: dict,\n    param_grid: Dict[str, list],\n    n_workers: Optional[int] = None,   # default: cpu_count\n)\n</code></pre>"},{"location":"api/optimization/#methods","title":"Methods","text":"Method Returns Description <code>run()</code> <code>SweepResults</code> Execute sweep"},{"location":"api/optimization/#sweepresults","title":"SweepResults","text":"<p>Ranked results from a parameter sweep.</p>"},{"location":"api/optimization/#fields","title":"Fields","text":"Field Type Description <code>combos</code> <code>List[dict]</code> Each combo has params + metrics"},{"location":"api/optimization/#methods_1","title":"Methods","text":"Method Returns Description <code>best(metric, n)</code> <code>List[dict]</code> Top N by metric (descending) <code>worst(metric, n)</code> <code>List[dict]</code> Bottom N by metric <code>filter(**kwargs)</code> <code>SweepResults</code> Filter by param values <code>to_dataframe()</code> <code>pd.DataFrame</code> Export as DataFrame <code>summary(metric, top_n)</code> <code>str</code> Formatted summary table"},{"location":"api/optimization/#combo-keys","title":"Combo Keys","text":"<p>Each dict in <code>combos</code> contains all parameter keys from <code>param_grid</code> plus:</p> Key Type Description <code>net_pnl</code> <code>float</code> Net PnL <code>net_return_pct</code> <code>float</code> Return percentage <code>max_drawdown_pct</code> <code>float</code> Max drawdown <code>total_trades</code> <code>int</code> Trade count <code>win_rate</code> <code>float</code> Win rate <code>profit_factor</code> <code>float</code> Profit factor"},{"location":"api/orders/","title":"Orders","text":""},{"location":"api/orders/#order-base","title":"Order (base)","text":"<p>Base class for all order types.</p>"},{"location":"api/orders/#fields","title":"Fields","text":"Field Type Default Description <code>side</code> <code>Side</code> required <code>Side.LONG</code> or <code>Side.SHORT</code> <code>size_usd</code> <code>Optional[float]</code> <code>None</code> Position size (None = use config default) <code>symbol</code> <code>str</code> <code>\"\"</code> Asset symbol <code>group</code> <code>Optional[str]</code> <code>None</code> Position group for independent tracking <code>take_profit_pct</code> <code>Optional[float]</code> <code>None</code> TP as fraction from entry (0.08 = 8%) <code>stop_loss_pct</code> <code>Optional[float]</code> <code>None</code> SL as fraction from entry (0.03 = 3%) <code>breakeven_trigger_pct</code> <code>Optional[float]</code> <code>None</code> Activate breakeven at this profit <code>breakeven_lock_pct</code> <code>Optional[float]</code> <code>None</code> Lock SL at this profit level <code>trailing_stop_pct</code> <code>Optional[float]</code> <code>None</code> Trail distance from peak <code>trailing_stop_activation_pct</code> <code>Optional[float]</code> <code>None</code> Min profit to start trailing <code>partial_tp_pct</code> <code>Optional[float]</code> <code>None</code> Fraction to close at TP (0.5 = 50%) <code>partial_tp_new_tp_pct</code> <code>Optional[float]</code> <code>None</code> New TP for remainder after partial close <code>cancel_pending_limits</code> <code>bool</code> <code>False</code> Cancel all pending limits when processed"},{"location":"api/orders/#marketorder","title":"MarketOrder","text":"<p>Fills at the next bar's open + adverse slippage.</p> <pre><code>from replaybt import MarketOrder, Side\n\norder = MarketOrder(\n    side=Side.LONG,\n    take_profit_pct=0.06,\n    stop_loss_pct=0.03,\n)\n</code></pre> <p>Inherits all <code>Order</code> fields. No additional fields.</p>"},{"location":"api/orders/#limitorder","title":"LimitOrder","text":"<p>Price-triggered entry. Fills when price crosses the limit level. Uses maker fees by default.</p> <pre><code>from replaybt import LimitOrder, Side\n\norder = LimitOrder(\n    side=Side.LONG,\n    limit_price=2300.0,\n    timeout_bars=120,\n    merge_position=True,\n)\n</code></pre>"},{"location":"api/orders/#additional-fields","title":"Additional Fields","text":"Field Type Default Description <code>limit_price</code> <code>float</code> <code>0.0</code> Fill price <code>timeout_bars</code> <code>int</code> <code>0</code> Cancel after N bars (0 = never) <code>use_maker_fee</code> <code>bool</code> <code>True</code> Use maker fee (False = taker) <code>min_positions</code> <code>int</code> <code>0</code> Only fill when &gt;= N positions exist <code>merge_position</code> <code>bool</code> <code>False</code> Merge into existing position"},{"location":"api/orders/#merge_position","title":"merge_position","text":"<p>When <code>True</code>, the limit order doesn't open a new position. Instead it merges into the existing one:</p> <ul> <li>Entry price becomes weighted average</li> <li>Position size increases</li> <li>SL/TP recalculate from new average entry</li> </ul>"},{"location":"api/orders/#min_positions","title":"min_positions","text":"<p>Guards against orphaned limit orders. If <code>min_positions=1</code>, the limit order only fills when at least one position exists. Useful for DCA scale-in orders that shouldn't fill after the main position has already closed.</p>"},{"location":"api/orders/#stoporder","title":"StopOrder","text":"<p>Fills when price breaks through the stop price. Becomes a market order on trigger.</p> <pre><code>from replaybt import StopOrder, Side\n\norder = StopOrder(\n    side=Side.LONG,\n    stop_price=2400.0,\n    timeout_bars=100,\n)\n</code></pre>"},{"location":"api/orders/#additional-fields_1","title":"Additional Fields","text":"Field Type Default Description <code>stop_price</code> <code>float</code> <code>0.0</code> Trigger price <code>timeout_bars</code> <code>int</code> <code>0</code> Cancel after N bars (0 = never)"},{"location":"api/orders/#cancelpendinglimitsorder","title":"CancelPendingLimitsOrder","text":"<p>Sentinel class. Return from <code>on_exit()</code> or <code>on_fill()</code> to cancel all pending limit orders without placing a new order.</p> <pre><code>from replaybt import CancelPendingLimitsOrder\n\ndef on_exit(self, fill, trade):\n    return CancelPendingLimitsOrder()\n</code></pre>"},{"location":"api/plots/","title":"Plots","text":"<p>Visualization functions for backtest results. Requires matplotlib:</p> <pre><code>pip install replaybt[plots]\n</code></pre> <p>All functions return a <code>matplotlib.figure.Figure</code>. Call <code>fig.savefig(\"plot.png\")</code> to save.</p> <pre><code>from replaybt.analysis.plots import plot_equity\n</code></pre>"},{"location":"api/plots/#plot_equity","title":"plot_equity","text":"<p>Equity curve with optional drawdown shading.</p> <pre><code>fig = plot_equity(results, show_drawdown=True, figsize=(12, 6))\nfig.savefig(\"equity.png\")\n</code></pre> Parameter Type Default Description <code>results</code> <code>BacktestResults</code> required Results with equity curve <code>show_drawdown</code> <code>bool</code> <code>True</code> Shade drawdown regions <code>figsize</code> <code>Tuple[int, int]</code> <code>(12, 6)</code> Figure size"},{"location":"api/plots/#plot_drawdown","title":"plot_drawdown","text":"<p>Drawdown as negative percentage filled area.</p> <pre><code>fig = plot_drawdown(results, figsize=(12, 4))\n</code></pre> Parameter Type Default Description <code>results</code> <code>BacktestResults</code> required Results with equity curve <code>figsize</code> <code>Tuple[int, int]</code> <code>(12, 4)</code> Figure size"},{"location":"api/plots/#plot_trades","title":"plot_trades","text":"<p>Entry/exit markers, optionally on a price chart.</p> <pre><code>fig = plot_trades(results, prices=price_list, figsize=(14, 6))\n</code></pre> Parameter Type Default Description <code>results</code> <code>BacktestResults</code> required Results with trades <code>prices</code> <code>Optional[List[Tuple]]</code> <code>None</code> <code>(timestamp, price)</code> tuples for price line <code>figsize</code> <code>Tuple[int, int]</code> <code>(14, 6)</code> Figure size <p>Markers: <code>^</code> = long entry, <code>v</code> = short entry, <code>x</code> = exit. Green = profit, red = loss.</p>"},{"location":"api/plots/#plot_monthly_heatmap","title":"plot_monthly_heatmap","text":"<p>Monthly PnL as a Year x Month heatmap.</p> <pre><code>fig = plot_monthly_heatmap(results, figsize=(10, 5))\n</code></pre> Parameter Type Default Description <code>results</code> <code>BacktestResults</code> required Results with monthly data <code>figsize</code> <code>Tuple[int, int]</code> <code>(10, 5)</code> Figure size <p>Green cells = profit, red cells = loss. Values annotated inside cells.</p>"},{"location":"api/plots/#plot_exit_breakdown","title":"plot_exit_breakdown","text":"<p>Exit reason breakdown as bar or pie chart.</p> <pre><code>fig = plot_exit_breakdown(results, kind=\"bar\", figsize=(8, 5))\n</code></pre> Parameter Type Default Description <code>results</code> <code>BacktestResults</code> required Results with exit breakdown <code>kind</code> <code>str</code> <code>\"bar\"</code> <code>\"bar\"</code> or <code>\"pie\"</code> <code>figsize</code> <code>Tuple[int, int]</code> <code>(8, 5)</code> Figure size"},{"location":"api/plots/#plot_multi_equity","title":"plot_multi_equity","text":"<p>Per-symbol equity curves with optional combined portfolio overlay.</p> <pre><code>fig = plot_multi_equity(multi_results, show_combined=True, figsize=(14, 7))\n</code></pre> Parameter Type Default Description <code>results</code> <code>MultiAssetResults</code> required Multi-asset results <code>show_combined</code> <code>bool</code> <code>True</code> Show combined equity line <code>figsize</code> <code>Tuple[int, int]</code> <code>(14, 7)</code> Figure size"},{"location":"api/plots/#plot_sweep_heatmap","title":"plot_sweep_heatmap","text":"<p>2D parameter sweep as a heatmap.</p> <pre><code>fig = plot_sweep_heatmap(\n    sweep_results,\n    x_param=\"take_profit_pct\",\n    y_param=\"stop_loss_pct\",\n    metric=\"net_pnl\",\n    figsize=(10, 7),\n)\n</code></pre> Parameter Type Default Description <code>results</code> <code>SweepResults</code> required Sweep results <code>x_param</code> <code>str</code> required Parameter for x-axis <code>y_param</code> <code>str</code> required Parameter for y-axis <code>metric</code> <code>str</code> <code>\"net_pnl\"</code> Metric to display <code>figsize</code> <code>Tuple[int, int]</code> <code>(10, 7)</code> Figure size"},{"location":"api/reporting/","title":"Reporting","text":""},{"location":"api/reporting/#backtestresults","title":"BacktestResults","text":"<p>Complete backtest results with all metrics.</p> <pre><code>results = engine.run()\nprint(results.summary())\nprint(results.monthly_table())\n</code></pre>"},{"location":"api/reporting/#fields","title":"Fields","text":"Field Type Description <code>symbol</code> <code>str</code> Asset symbol <code>initial_equity</code> <code>float</code> Starting capital <code>final_equity</code> <code>float</code> Ending capital <code>net_pnl</code> <code>float</code> Net profit/loss <code>net_return_pct</code> <code>float</code> Return percentage <code>max_drawdown_pct</code> <code>float</code> Peak-to-trough drawdown <code>total_trades</code> <code>int</code> Number of trades <code>winning_trades</code> <code>int</code> Profitable trades <code>losing_trades</code> <code>int</code> Unprofitable trades <code>win_rate</code> <code>float</code> Win rate (0-100) <code>avg_win</code> <code>float</code> Average win in USD <code>avg_loss</code> <code>float</code> Average loss in USD (absolute) <code>avg_win_pct</code> <code>float</code> Average win percent <code>avg_loss_pct</code> <code>float</code> Average loss percent <code>profit_factor</code> <code>float</code> Gross profit / gross loss <code>total_fees</code> <code>float</code> Cumulative fees <code>trades</code> <code>List[Trade]</code> All closed trades <code>exit_breakdown</code> <code>Dict[str, int]</code> Count by exit reason <code>equity_curve</code> <code>List[Tuple[datetime, float]]</code> Equity after each trade <code>buy_hold_return_pct</code> <code>Optional[float]</code> Buy &amp; hold return <code>first_price</code> <code>Optional[float]</code> First bar close <code>last_price</code> <code>Optional[float]</code> Last bar close <code>monthly</code> <code>List[MonthStats]</code> Monthly breakdown"},{"location":"api/reporting/#methods","title":"Methods","text":"Method Returns Description <code>summary()</code> <code>str</code> Formatted summary table <code>monthly_table()</code> <code>str</code> Monthly breakdown table"},{"location":"api/reporting/#class-methods","title":"Class Methods","text":"Method Returns Description <code>from_portfolio(portfolio, symbol, first_bar, last_bar)</code> <code>BacktestResults</code> Build from Portfolio"},{"location":"api/reporting/#multiassetresults","title":"MultiAssetResults","text":"<p>Combined results from multi-asset backtest.</p> <pre><code>results = multi_engine.run()\nprint(results.summary())\n</code></pre>"},{"location":"api/reporting/#fields_1","title":"Fields","text":"Field Type Description <code>per_symbol</code> <code>Dict[str, BacktestResults]</code> Individual results <code>combined_equity_curve</code> <code>List[Tuple[datetime, float]]</code> Summed equity <code>combined_max_drawdown_pct</code> <code>float</code> Portfolio drawdown <code>combined_net_pnl</code> <code>float</code> Total PnL <code>combined_return_pct</code> <code>float</code> Total return <code>combined_total_trades</code> <code>int</code> Total trades <code>combined_win_rate</code> <code>float</code> Combined win rate <code>combined_total_fees</code> <code>float</code> Total fees <code>combined_profit_factor</code> <code>float</code> Combined profit factor <code>total_initial_equity</code> <code>float</code> Sum of initial equities <code>combined_monthly</code> <code>List[MonthStats]</code> Combined monthly breakdown"},{"location":"api/reporting/#methods_1","title":"Methods","text":"Method Returns Description <code>summary()</code> <code>str</code> Combined + per-symbol summary <code>monthly_table()</code> <code>str</code> Combined monthly table"},{"location":"api/reporting/#class-methods_1","title":"Class Methods","text":"Method Returns Description <code>from_portfolios(portfolios, first_bars, last_bars, config)</code> <code>MultiAssetResults</code> Build from per-symbol portfolios"},{"location":"api/reporting/#monthstats","title":"MonthStats","text":"<p>Statistics for a single month.</p> Field Type Description <code>year</code> <code>int</code> Year <code>month</code> <code>int</code> Month (1-12) <code>trades</code> <code>int</code> Trade count <code>wins</code> <code>int</code> Winning trades <code>losses</code> <code>int</code> Losing trades <code>gross_profit</code> <code>float</code> Sum of winning PnL <code>gross_loss</code> <code>float</code> Sum of losing PnL <code>net_pnl</code> <code>float</code> Net PnL <code>fees</code> <code>float</code> Fees paid <code>max_win</code> <code>float</code> Largest win <code>max_loss</code> <code>float</code> Largest loss"},{"location":"api/reporting/#properties","title":"Properties","text":"Property Type Description <code>win_rate</code> <code>float</code> Win rate (0-100) <code>label</code> <code>str</code> \"YYYY-MM\""},{"location":"api/reporting/#utility-functions","title":"Utility Functions","text":"<pre><code>from replaybt import monthly_breakdown, format_monthly_table\n\nmonths = monthly_breakdown(trades)\ntable = format_monthly_table(months, initial_equity=10_000)\n</code></pre>"},{"location":"api/sizing/","title":"Sizing","text":""},{"location":"api/sizing/#positionsizer-abc","title":"PositionSizer (ABC)","text":"<p>Abstract base for position sizing strategies.</p> <pre><code>from replaybt import PositionSizer\n\nclass MySizer(PositionSizer):\n    def get_size(self, equity, side, price, symbol=\"\", stop_loss_pct=0.0):\n        return equity * 0.1  # 10% of equity\n</code></pre>"},{"location":"api/sizing/#abstract-method","title":"Abstract Method","text":"<pre><code>def get_size(\n    self,\n    equity: float,       # current portfolio equity\n    side: str,            # \"LONG\" or \"SHORT\"\n    price: float,         # current price\n    symbol: str = \"\",     # asset symbol\n    stop_loss_pct: float = 0.0,  # SL distance (for risk-based sizing)\n) -&gt; float:  # position size in USD\n</code></pre>"},{"location":"api/sizing/#fixedsizer","title":"FixedSizer","text":"<p>Constant USD position size.</p> <pre><code>from replaybt import FixedSizer\n\nsizer = FixedSizer(size_usd=10_000)\n</code></pre> Parameter Type Default Description <code>size_usd</code> <code>float</code> <code>10_000</code> Fixed size"},{"location":"api/sizing/#equitypctsizer","title":"EquityPctSizer","text":"<p>Size as a percentage of current equity.</p> <pre><code>from replaybt import EquityPctSizer\n\nsizer = EquityPctSizer(pct=0.10, min_size=100, max_size=50_000)\n</code></pre> Parameter Type Default Description <code>pct</code> <code>float</code> <code>0.10</code> Fraction of equity (0.10 = 10%) <code>min_size</code> <code>float</code> <code>100</code> Minimum position size <code>max_size</code> <code>float</code> <code>0</code> Maximum size (0 = no cap)"},{"location":"api/sizing/#riskpctsizer","title":"RiskPctSizer","text":"<p>Size so that a stop-loss hit loses at most <code>risk_pct</code> of equity.</p> <p>Formula: <code>size = (equity * risk_pct) / stop_loss_pct</code></p> <pre><code>from replaybt import RiskPctSizer\n\nsizer = RiskPctSizer(risk_pct=0.01, default_sl_pct=0.035)\n</code></pre> Parameter Type Default Description <code>risk_pct</code> <code>float</code> <code>0.01</code> Max equity at risk per trade (1%) <code>min_size</code> <code>float</code> <code>100</code> Minimum position size <code>max_size</code> <code>float</code> <code>0</code> Maximum size (0 = no cap) <code>default_sl_pct</code> <code>float</code> <code>0.035</code> Default SL if none provided <p>Example: With $10,000 equity, 1% risk, and 3.5% SL:</p> <p><code>size = ($10,000 * 0.01) / 0.035 = $2,857</code></p> <p>If the trade hits SL, you lose $2,857 * 3.5% = $100 = 1% of equity.</p>"},{"location":"api/sizing/#kellysizer","title":"KellySizer","text":"<p>Position sizing using the Kelly criterion.</p> <p>Formula: <code>f* = win_rate - (1 - win_rate) / payoff_ratio</code></p> <pre><code>from replaybt import KellySizer\n\nsizer = KellySizer(\n    win_rate=0.60,\n    avg_win=0.08,\n    avg_loss=0.035,\n    fraction=0.25,  # quarter-Kelly\n)\n</code></pre> Parameter Type Default Description <code>win_rate</code> <code>float</code> <code>0.60</code> Historical win rate (0-1) <code>avg_win</code> <code>float</code> <code>0.08</code> Avg winning trade % <code>avg_loss</code> <code>float</code> <code>0.035</code> Avg losing trade % <code>fraction</code> <code>float</code> <code>0.25</code> Kelly fraction (1.0 = full Kelly) <code>min_size</code> <code>float</code> <code>100</code> Minimum size <code>max_size</code> <code>float</code> <code>0</code> Maximum size (0 = no cap) <code>max_equity_pct</code> <code>float</code> <code>0.25</code> Max fraction of equity"},{"location":"api/sizing/#properties","title":"Properties","text":"Property Type Description <code>kelly_fraction</code> <code>float</code> Raw Kelly before fractional multiplier"},{"location":"api/sizing/#using-a-sizer","title":"Using a Sizer","text":"<p>Pass to the engine config:</p> <pre><code>engine = BacktestEngine(\n    strategy=my_strategy,\n    data=data,\n    config={\n        \"initial_equity\": 10_000,\n        \"sizer\": RiskPctSizer(risk_pct=0.01),\n    },\n)\n</code></pre> <p>When a sizer is set, <code>default_size_usd</code> is ignored and the sizer determines position size for each trade.</p>"},{"location":"api/strategy/","title":"Strategy","text":""},{"location":"api/strategy/#strategy-abc","title":"Strategy (ABC)","text":"<p>Abstract base class. Implement <code>on_bar()</code> to create a strategy.</p> <pre><code>from replaybt import Strategy, MarketOrder, Side\n\nclass MyStrategy(Strategy):\n    def configure(self, config):\n        self._state = None\n\n    def on_bar(self, bar, indicators, positions):\n        return None  # or Order\n</code></pre>"},{"location":"api/strategy/#methods","title":"Methods","text":"Method Signature Description <code>configure</code> <code>(config: dict) -&gt; None</code> Called once before first bar <code>on_bar</code> <code>(bar, indicators, positions) -&gt; Order \\| List[Order] \\| None</code> Required. Emit signals <code>on_fill</code> <code>(fill: Fill) -&gt; Optional[Order]</code> After entry/merge fill <code>on_exit</code> <code>(fill: Fill, trade: Trade) -&gt; Order \\| CancelPendingLimitsOrder \\| None</code> After position close <code>check_exits</code> <code>(bar: Bar, positions: List[Position]) -&gt; List[Tuple]</code> Custom exit logic"},{"location":"api/strategy/#on_bar-return-types","title":"on_bar Return Types","text":"Return Behavior <code>None</code> No action <code>MarketOrder</code> Replaces pending market order <code>LimitOrder</code> Appends to pending limit queue <code>StopOrder</code> Appends to pending stop queue <code>List[Order]</code> Last MarketOrder wins; LimitOrders stack"},{"location":"api/strategy/#check_exits-return-format","title":"check_exits Return Format","text":"<pre><code># Full close\n[(position_index, exit_price, reason_string)]\n\n# Partial close\n[(position_index, exit_price, reason_string, close_fraction)]\n</code></pre>"},{"location":"api/strategy/#declarativestrategy","title":"DeclarativeStrategy","text":"<p>JSON-config strategy. No Python subclassing needed.</p> <pre><code>from replaybt import DeclarativeStrategy\n\n# From JSON file\nstrategy = DeclarativeStrategy.from_json(\"config.json\")\n\n# From dict\nstrategy = DeclarativeStrategy.from_config(config_dict)\n</code></pre>"},{"location":"api/strategy/#class-methods","title":"Class Methods","text":"Method Returns Description <code>from_json(path)</code> <code>DeclarativeStrategy</code> Load from JSON file <code>from_config(config)</code> <code>DeclarativeStrategy</code> Create from dict"},{"location":"api/strategy/#instance-methods","title":"Instance Methods","text":"Method Returns Description <code>indicator_config()</code> <code>Dict</code> Indicator config for engine <code>on_bar(bar, indicators, positions)</code> <code>Optional[Order]</code> Execute declarative logic"},{"location":"api/strategy/#condition-types","title":"Condition Types","text":"Type Fields Description <code>crossover</code> <code>fast</code>, <code>slow</code> fast &gt; slow AND prev_fast &lt;= prev_slow <code>crossunder</code> <code>fast</code>, <code>slow</code> fast &lt; slow AND prev_fast &gt;= prev_slow <code>above</code> <code>left</code>, <code>right</code> left &gt; right <code>below</code> <code>left</code>, <code>right</code> left &lt; right <code>above_threshold</code> <code>indicator</code>, <code>threshold</code> value &gt;= threshold <code>below_threshold</code> <code>indicator</code>, <code>threshold</code> value &lt;= threshold <code>crosses_above</code> <code>indicator</code>, <code>threshold</code> now &gt; threshold AND prev &lt;= threshold <code>crosses_below</code> <code>indicator</code>, <code>threshold</code> now &lt; threshold AND prev &gt;= threshold"},{"location":"api/strategy/#strategyconfig","title":"StrategyConfig","text":"<p>Per-symbol configuration with defaults and overrides.</p> <pre><code>from replaybt import StrategyConfig\n\nconfig = StrategyConfig(\n    defaults={\"tp\": 0.06, \"sl\": 0.03},\n    overrides={\"ETH\": {\"tp\": 0.08, \"sl\": 0.04}},\n)\n</code></pre>"},{"location":"api/strategy/#constructor","title":"Constructor","text":"<pre><code>StrategyConfig(\n    defaults: Optional[Dict[str, Any]] = None,\n    overrides: Optional[Dict[str, Dict[str, Any]]] = None,\n)\n</code></pre>"},{"location":"api/strategy/#methods_1","title":"Methods","text":"Method Returns Description <code>get(key, symbol, default)</code> <code>Any</code> Get value, checking overrides first <code>for_symbol(symbol)</code> <code>Dict[str, Any]</code> Merged config for a symbol <code>symbols()</code> <code>list</code> Symbols with overrides"},{"location":"api/validation/","title":"Validation","text":""},{"location":"api/validation/#backtestauditor","title":"BacktestAuditor","text":"<p>Static source code auditor. Scans Python files for 11 common backtest bias patterns.</p> <pre><code>from replaybt import BacktestAuditor\n\nauditor = BacktestAuditor(source_code, filename=\"my_backtest.py\")\nissues = auditor.audit()\nprint(auditor.report())\n</code></pre>"},{"location":"api/validation/#constructor","title":"Constructor","text":"<pre><code>BacktestAuditor(source: str, filename: str = \"&lt;unknown&gt;\")\n</code></pre>"},{"location":"api/validation/#methods","title":"Methods","text":"Method Returns Description <code>audit()</code> <code>List[Issue]</code> Run all checks <code>report()</code> <code>str</code> Formatted report"},{"location":"api/validation/#checks","title":"Checks","text":"# Check Severity Description 1 Same-bar execution CRITICAL Signal and entry on same bar 2 Indicator lookahead WARNING Pre-calculated without exclusion 3 Exit price assumptions WARNING No gap protection 4 Missing pending_order CRITICAL No pending order system 5 Time alignment WARNING Incomplete bar lookup 6 Missing fees WARNING No slippage/fees 7 Future data access CRITICAL <code>iloc[i+1]</code> 8 Signal/exit same iter WARNING Signal and exit in same loop 9 Missing 1m data INFO Not using 1m bars 10 Wrapper delegation INFO Script delegates to another 11 Scale-in bias WARNING Scale-in without timing guard"},{"location":"api/validation/#issue","title":"Issue","text":"<p>A single audit finding. Frozen dataclass.</p> Field Type Description <code>severity</code> <code>str</code> <code>\"CRITICAL\"</code>, <code>\"WARNING\"</code>, <code>\"INFO\"</code> <code>line</code> <code>int</code> Source line number <code>code</code> <code>str</code> Code snippet <code>message</code> <code>str</code> Explanation <code>fix</code> <code>str</code> Suggested fix"},{"location":"api/validation/#audit_file","title":"audit_file","text":"<p>Convenience function to audit a file by path.</p> <pre><code>from replaybt.validation.auditor import audit_file\n\nissues = audit_file(\"my_backtest.py\")\nfor issue in issues:\n    print(f\"[{issue.severity}] line {issue.line}: {issue.message}\")\n</code></pre>"},{"location":"api/validation/#delaytest","title":"DelayTest","text":"<p>Adds +N bar latency to detect timing sensitivity. If PnL drops significantly, the strategy may have look-ahead bias.</p> <pre><code>from replaybt import DelayTest\n\nresult = DelayTest(\n    strategy_factory=MyStrategy,   # CLASS, not instance\n    data=data_provider,\n    config=engine_config,\n    delay_bars=1,\n    fail_threshold=0.50,           # 50% PnL drop = FAIL\n).run()\n</code></pre>"},{"location":"api/validation/#constructor_1","title":"Constructor","text":"<pre><code>DelayTest(\n    strategy_factory: Callable[[], Strategy],\n    data: DataProvider,\n    config: dict,\n    delay_bars: int = 1,\n    fail_threshold: float = 0.50,\n)\n</code></pre>"},{"location":"api/validation/#delaytestresult","title":"DelayTestResult","text":"Field Type Description <code>normal</code> <code>BacktestResults</code> Normal backtest <code>delayed</code> <code>BacktestResults</code> +N bar delay <code>delay_bars</code> <code>int</code> Bars of delay added <code>pnl_change_pct</code> <code>float</code> PnL change percent <code>wr_change</code> <code>float</code> Win rate change <code>verdict</code> <code>str</code> <code>\"PASS\"</code> or <code>\"FAIL\"</code>"},{"location":"api/validation/#oossplit","title":"OOSSplit","text":"<p>Train/test out-of-sample split. Detects overfitting by comparing performance on train vs test periods.</p> <pre><code>from replaybt import OOSSplit\n\nresult = OOSSplit(\n    strategy_factory=MyStrategy,\n    data=data_provider,\n    config=engine_config,\n    split_ratio=0.5,\n    fail_wr_divergence=0.10,\n    fail_oos_pct=0.25,\n).run()\n</code></pre>"},{"location":"api/validation/#constructor_2","title":"Constructor","text":"<pre><code>OOSSplit(\n    strategy_factory: Callable[[], Strategy],\n    data: DataProvider,\n    config: dict,\n    split_ratio: float = 0.5,\n    fail_wr_divergence: float = 0.10,\n    fail_oos_pct: float = 0.25,\n)\n</code></pre>"},{"location":"api/validation/#oosresult","title":"OOSResult","text":"Field Type Description <code>train</code> <code>BacktestResults</code> Training period <code>test</code> <code>BacktestResults</code> Test period <code>split_ratio</code> <code>float</code> Split ratio used <code>verdict</code> <code>str</code> <code>\"PASS\"</code> or <code>\"FAIL\"</code> <code>issues</code> <code>List[str]</code> Failure reasons"},{"location":"concepts/","title":"Concepts","text":"<p>These pages explain the core mechanics that make replaybt different from other backtesting frameworks.</p> Page What you'll learn Execution Loop The 4-phase bar processing pipeline Signal Timing Why signals at T fill at T+1, and how pending orders work Gap Protection How open gaps affect stop and target fills Multi-Timeframe Computing indicators on higher timeframes from 1m data"},{"location":"concepts/#the-core-principle","title":"The Core Principle","text":"<p>In real trading:</p> <ol> <li>A bar closes</li> <li>You see the close price</li> <li>You compute indicators</li> <li>You place an order</li> <li>The order fills at the next bar's open</li> </ol> <p>Most backtesting frameworks skip step 5 and fill at the close of the signal bar. This creates look-ahead bias \u2014 you're buying at a price you couldn't have bought at in production.</p> <p>replaybt enforces realistic execution by design. The engine manages the order lifecycle; your strategy only emits signals.</p>"},{"location":"concepts/execution-loop/","title":"Execution Loop","text":"<p>Every bar passes through four phases in strict order. The engine never skips or reorders phases.</p>"},{"location":"concepts/execution-loop/#the-4-phases","title":"The 4 Phases","text":"<pre><code>Bar arrives (1-minute candle)\n\u2502\n\u251c\u2500 Phase 1: Fill pending orders\n\u2502  \u251c\u2500 Market orders \u2192 fill at bar OPEN + adverse slippage\n\u2502  \u2514\u2500 Limit orders \u2192 check if price crossed limit level\n\u2502\n\u251c\u2500 Phase 2: Check exits\n\u2502  \u251c\u2500 Gap check \u2192 did OPEN gap past SL/TP?\n\u2502  \u251c\u2500 Intra-bar \u2192 check HIGH/LOW against SL/TP levels\n\u2502  \u251c\u2500 Breakeven \u2192 activate if profit threshold reached\n\u2502  \u2514\u2500 Trailing stop \u2192 update trail, check if hit\n\u2502\n\u251c\u2500 Phase 3: Strategy exits\n\u2502  \u2514\u2500 check_exits() \u2192 strategy-initiated closes\n\u2502\n\u2514\u2500 Phase 4: Signals\n   \u251c\u2500 on_bar() \u2192 strategy sees COMPLETED bar + indicators\n   \u2514\u2500 Returned orders become PENDING for next bar\n</code></pre>"},{"location":"concepts/execution-loop/#why-this-order-matters","title":"Why This Order Matters","text":"<p>Phase 1 before Phase 4 ensures that signals from bar T fill at bar T+1's open. Your strategy never sees incomplete data.</p> <p>Phase 2 before Phase 4 ensures exits are processed before new signals. If a position closes this bar, the strategy can optionally emit a new signal on the same bar (controlled by <code>skip_signal_on_close</code>).</p> <p>Phase 3 between Phase 2 and Phase 4 gives your strategy a chance to close positions based on custom logic (via <code>check_exits</code>) before <code>on_bar</code> runs.</p>"},{"location":"concepts/execution-loop/#example-one-bars-lifecycle","title":"Example: One Bar's Lifecycle","text":"<pre><code># Bar T-1: strategy sees EMA crossover, returns MarketOrder(LONG)\n# \u2192 order becomes PENDING\n\n# Bar T arrives:\n#   Phase 1: pending LONG fills at bar T's open ($2,300.50 + slippage)\n#   Phase 2: check SL/TP against bar T's high/low \u2014 no exit\n#   Phase 3: check_exits() \u2014 no custom exit\n#   Phase 4: on_bar() runs with bar T data \u2014 no new signal\n\n# Bar T+1 arrives:\n#   Phase 1: no pending orders\n#   Phase 2: bar T+1's low hits SL \u2192 exit at SL level\n#   Phase 3: skipped (position already closed)\n#   Phase 4: on_bar() runs \u2014 could emit new signal\n</code></pre>"},{"location":"concepts/execution-loop/#configuration","title":"Configuration","text":"<pre><code>engine = BacktestEngine(\n    strategy=my_strategy,\n    data=data,\n    config={\n        # Phase 1 settings\n        \"slippage\": 0.0002,       # 0.02% per side, adverse direction\n        \"taker_fee\": 0.00015,     # 0.015% per side\n        \"maker_fee\": 0.0,         # for limit orders\n\n        # Phase 4 settings\n        \"skip_signal_on_close\": True,   # skip on_bar when position closes\n        \"same_direction_only\": True,    # reject opposite-direction orders\n    },\n)\n</code></pre>"},{"location":"concepts/execution-loop/#event-hooks","title":"Event Hooks","text":"<p>You can observe each phase without modifying the loop:</p> <pre><code>engine.on(\"fill\", lambda fill: print(f\"Filled: {fill}\"))\nengine.on(\"exit\", lambda fill, trade: print(f\"Exit: {trade.reason}\"))\nengine.on(\"bar\", lambda bar: None)  # every bar\nengine.on(\"signal\", lambda order: print(f\"Signal: {order.side}\"))\n</code></pre>"},{"location":"concepts/gap-protection/","title":"Gap Protection","text":""},{"location":"concepts/gap-protection/#the-problem","title":"The Problem","text":"<p>In volatile markets, the next bar's open can gap past your stop loss or take profit level. If you always fill at the exact level, you're giving yourself a better price than the market actually offered.</p>"},{"location":"concepts/gap-protection/#how-replaybt-handles-it","title":"How replaybt Handles It","text":"<p>The engine checks the bar's open price first, before checking high/low:</p> <pre><code>Bar opens\n\u2502\n\u251c\u2500 Open gapped past SL? \u2192 Exit at OPEN (worse fill)\n\u251c\u2500 Open gapped past TP? \u2192 Exit at OPEN (better fill than expected)\n\u2502\n\u251c\u2500 Otherwise, check High/Low:\n\u2502  \u251c\u2500 High/Low hit SL? \u2192 Exit at SL level\n\u2502  \u2514\u2500 High/Low hit TP? \u2192 Exit at TP level\n\u2502\n\u2514\u2500 No exit triggered \u2192 position stays open\n</code></pre>"},{"location":"concepts/gap-protection/#the-4-cases","title":"The 4 Cases","text":""},{"location":"concepts/gap-protection/#long-position","title":"LONG Position","text":"Scenario Exit Price Reason Open gaps below SL Open price (worse) <code>STOP_LOSS_GAP</code> Low touches SL intra-bar SL level (exact) <code>STOP_LOSS</code> Open gaps above TP Open price (better) <code>TAKE_PROFIT_GAP</code> High touches TP intra-bar TP level (exact) <code>TAKE_PROFIT</code>"},{"location":"concepts/gap-protection/#short-position","title":"SHORT Position","text":"Scenario Exit Price Reason Open gaps above SL Open price (worse) <code>STOP_LOSS_GAP</code> High touches SL intra-bar SL level (exact) <code>STOP_LOSS</code> Open gaps below TP Open price (better) <code>TAKE_PROFIT_GAP</code> Low touches TP intra-bar TP level (exact) <code>TAKE_PROFIT</code>"},{"location":"concepts/gap-protection/#example","title":"Example","text":"<pre><code># LONG position entered at $2,000 with SL at $1,930 (3.5%)\n# Bar opens at $1,920 (gapped below SL)\n\n# WRONG: exit at $1,930 (the SL level)\n# CORRECT: exit at $1,920 (the actual open price \u2014 worse fill)\n</code></pre>"},{"location":"concepts/gap-protection/#adverse-slippage-on-exits","title":"Adverse Slippage on Exits","text":"<p>After determining the exit price, adverse slippage is applied:</p> <ul> <li>LONG exit: price moves down (you receive less)</li> <li>SHORT exit: price moves up (you pay more)</li> </ul> <pre><code># Exit price = $1,920 (gap)\n# Slippage = 0.02%\n# Actual fill = $1,920 * (1 - 0.0002) = $1,919.62\n</code></pre>"},{"location":"concepts/gap-protection/#why-this-matters","title":"Why This Matters","text":"<p>Without gap protection, backtests overstate performance on volatile assets. A strategy that shows +50% might actually produce +20% when gap-through exits are properly modeled.</p> <p>The <code>exit_breakdown</code> in results tells you how many exits were gap-triggered:</p> <pre><code>results = engine.run()\nprint(results.exit_breakdown)\n# {'STOP_LOSS': 15, 'STOP_LOSS_GAP': 3, 'TAKE_PROFIT': 20, 'TAKE_PROFIT_GAP': 1, ...}\n</code></pre> <p>Gap variants (<code>_GAP</code> suffix) are collapsed in the summary display but tracked separately in the raw breakdown.</p>"},{"location":"concepts/multi-timeframe/","title":"Multi-Timeframe","text":""},{"location":"concepts/multi-timeframe/#the-approach","title":"The Approach","text":"<p>Feed 1-minute data to the engine. Compute indicators on higher timeframes (5m, 15m, 30m, 1h, etc.) automatically. The engine handles resampling internally.</p> <pre><code>config = {\n    \"indicators\": {\n        # Computed on 30-minute bars (resampled from 1m)\n        \"ema_fast\": {\"type\": \"ema\", \"period\": 15, \"timeframe\": \"30m\", \"source\": \"close\"},\n        \"ema_slow\": {\"type\": \"ema\", \"period\": 35, \"timeframe\": \"30m\", \"source\": \"close\"},\n\n        # Computed on 1-hour bars\n        \"chop\": {\"type\": \"chop\", \"period\": 14, \"timeframe\": \"1h\"},\n\n        # Computed on 1-minute bars (default \u2014 no timeframe key needed)\n        \"rsi\": {\"type\": \"rsi\", \"period\": 7},\n    },\n}\n</code></pre>"},{"location":"concepts/multi-timeframe/#how-resampling-works","title":"How Resampling Works","text":"<p>The <code>IndicatorManager</code> accumulates 1-minute bars and builds higher-timeframe bars internally:</p> <pre><code>1m bars arrive:  [00:00, 00:01, ..., 00:29]\n                          \u2193\n30m bar formed:  [00:00 open, max(highs), min(lows), 00:29 close, sum(volumes)]\n                          \u2193\nIndicator updated with completed 30m bar\n                          \u2193\nValue available in indicators dict\n</code></pre> <p>Indicators on higher timeframes update only when a complete higher-timeframe bar forms. Between updates, they return the previous value.</p>"},{"location":"concepts/multi-timeframe/#supported-timeframes","title":"Supported Timeframes","text":"<p><code>\"1m\"</code>, <code>\"5m\"</code>, <code>\"15m\"</code>, <code>\"30m\"</code>, <code>\"1h\"</code>, <code>\"2h\"</code>, <code>\"4h\"</code>, <code>\"1d\"</code></p>"},{"location":"concepts/multi-timeframe/#completed-bar-rule","title":"Completed Bar Rule","text":"<p>Indicators always use the last completed higher-timeframe bar, never the in-progress one:</p> <pre><code>Time: 10:15\n  30m indicator uses the bar [09:30 - 10:00]  (completed)\n  NOT the bar [10:00 - 10:30]  (still forming)\n</code></pre> <p>This is enforced automatically by the <code>IndicatorManager</code>. You don't need to manage offsets yourself.</p>"},{"location":"concepts/multi-timeframe/#batch-resampling","title":"Batch Resampling","text":"<p>For pre-computing indicators on DataFrames (useful in parameter sweeps), use the <code>Resampler</code> utility:</p> <pre><code>from replaybt import Resampler\nimport pandas as pd\n\ndf_1m = pd.read_csv(\"ETH_1m.csv\", parse_dates=[\"timestamp\"])\n\n# Resample to 30m bars\ndf_30m = Resampler.resample(df_1m, \"30m\")\n\n# Add indicators to the resampled DataFrame\ndf_30m = Resampler.add_ema(df_30m, period=15, col=\"close\", name=\"ema_fast\")\ndf_30m = Resampler.add_ema(df_30m, period=35, col=\"close\", name=\"ema_slow\")\ndf_30m = Resampler.add_rsi_wilder(df_30m, period=14, name=\"rsi_14\")\ndf_30m = Resampler.add_chop(df_30m, period=14, name=\"chop_14\")\n</code></pre>"},{"location":"concepts/multi-timeframe/#mixing-timeframes","title":"Mixing Timeframes","text":"<p>You can mix indicators from different timeframes freely. The engine tracks each timeframe's resampling state independently:</p> <pre><code>config = {\n    \"indicators\": {\n        \"ema_30m\": {\"type\": \"ema\", \"period\": 15, \"timeframe\": \"30m\", \"source\": \"close\"},\n        \"rsi_1h\":  {\"type\": \"rsi\", \"period\": 14, \"timeframe\": \"1h\"},\n        \"atr_1m\":  {\"type\": \"atr\", \"period\": 14},  # 1m default\n    },\n}\n</code></pre> <p>In <code>on_bar()</code>, all indicator values are available in a single dict:</p> <pre><code>def on_bar(self, bar, indicators, positions):\n    ema = indicators.get(\"ema_30m\")      # updates every 30 bars\n    rsi = indicators.get(\"rsi_1h\")       # updates every 60 bars\n    atr = indicators.get(\"atr_1m\")       # updates every bar\n</code></pre>"},{"location":"concepts/signal-timing/","title":"Signal Timing","text":""},{"location":"concepts/signal-timing/#the-t-t1-rule","title":"The T / T+1 Rule","text":"<pre><code>WRONG (look-ahead bias):\n  Signal at bar T close \u2192 Entry at bar T close\n\nCORRECT (realistic):\n  Signal at bar T close \u2192 Entry at bar T+1 open\n</code></pre> <p>When <code>on_bar()</code> returns an <code>Order</code>, the engine does not fill it immediately. The order becomes pending and fills at the next bar's open with adverse slippage applied.</p>"},{"location":"concepts/signal-timing/#how-pending-orders-work","title":"How Pending Orders Work","text":"<pre><code>class MyStrategy(Strategy):\n    def on_bar(self, bar, indicators, positions):\n        if some_condition:\n            # This order is NOT filled now.\n            # It becomes pending and fills at the NEXT bar's open.\n            return MarketOrder(side=Side.LONG, take_profit_pct=0.05)\n        return None\n</code></pre> <p>Internally:</p> <ol> <li><code>on_bar()</code> returns a <code>MarketOrder</code> during Phase 4 of bar T</li> <li>The engine stores it as a pending order</li> <li>At the start of bar T+1 (Phase 1), the pending order fills at <code>bar_T1.open * (1 + slippage)</code></li> </ol>"},{"location":"concepts/signal-timing/#multiple-orders","title":"Multiple Orders","text":"<p><code>on_bar()</code> can return a single order or a list:</p> <pre><code>def on_bar(self, bar, indicators, positions):\n    orders = []\n\n    # Last MarketOrder wins (overwrites previous pending market order)\n    orders.append(MarketOrder(side=Side.LONG))\n\n    # LimitOrders stack (all are added to the pending limit queue)\n    orders.append(LimitOrder(side=Side.LONG, limit_price=2300.0))\n    orders.append(LimitOrder(side=Side.LONG, limit_price=2250.0))\n\n    return orders\n</code></pre> <p>Rules:</p> <ul> <li>MarketOrder: the last one returned replaces any previous pending market order</li> <li>LimitOrder: each one is appended to the pending limit queue</li> <li>StopOrder: each one is appended to the pending stop queue</li> </ul>"},{"location":"concepts/signal-timing/#skip_signal_on_close","title":"skip_signal_on_close","text":"<p>When a position closes during Phase 2 or 3 of a bar, should <code>on_bar()</code> still run?</p> <pre><code>config = {\n    \"skip_signal_on_close\": True,   # default \u2014 skip on_bar after exit\n    # \"skip_signal_on_close\": False,  # for mean-reversion re-entry\n}\n</code></pre> <ul> <li>True (default): if a position closes this bar, <code>on_bar()</code> is skipped. Prevents same-bar re-entry after a stop or target hit. Good for trend-following.</li> <li>False: <code>on_bar()</code> always runs. Allows immediate re-entry after an exit. Good for mean-reversion strategies where you want to flip direction on exit.</li> </ul>"},{"location":"concepts/signal-timing/#same_direction_only","title":"same_direction_only","text":"<pre><code>config = {\n    \"same_direction_only\": True,  # default \u2014 reject opposite orders\n}\n</code></pre> <p>When True, if you have a LONG position open and <code>on_bar()</code> returns a SHORT order, the order is silently rejected. Set False to allow hedging.</p>"},{"location":"concepts/signal-timing/#verifying-your-timing","title":"Verifying Your Timing","text":"<p>Use the DelayTest to add +1 bar latency. If PnL drops dramatically, your strategy may have hidden timing sensitivity:</p> <pre><code>from replaybt.validation.stress import DelayTest\n\nresult = DelayTest(\n    strategy_factory=MyStrategy,\n    data=data,\n    config=config,\n    delay_bars=1,\n).run()\nprint(result.verdict)  # \"PASS\" or \"FAIL\"\n</code></pre>"},{"location":"cookbook/","title":"Cookbook","text":"<p>Working recipes for common strategy patterns. Each page leads with a complete, runnable example.</p> Recipe Pattern Key Concept EMA Crossover Trend following Basic <code>on_bar</code> + <code>MarketOrder</code> Mean Reversion RSI-based entries <code>skip_signal_on_close=False</code> Scale-In DCA / second entries <code>on_fill</code> + <code>LimitOrder(merge_position=True)</code> Breakeven Stop Lock in small profit <code>breakeven_trigger_pct</code> / <code>breakeven_lock_pct</code> Trailing Stop Follow price peaks <code>trailing_stop_pct</code> + activation Multi-Asset Portfolio backtest <code>MultiAssetEngine</code> + exposure cap RL Agent Reinforcement learning <code>StepEngine</code> step/reset"},{"location":"cookbook/breakeven/","title":"Breakeven Stop","text":"<p>Move the stop loss to lock in a small profit once the trade reaches a threshold.</p>"},{"location":"cookbook/breakeven/#complete-example","title":"Complete Example","text":"<pre><code>from replaybt import BacktestEngine, CSVProvider, Strategy, MarketOrder, Side\n\n\nclass BreakevenStrategy(Strategy):\n    def configure(self, config):\n        self._prev_fast = self._prev_slow = None\n\n    def on_bar(self, bar, indicators, positions):\n        fast = indicators.get(\"ema_fast\")\n        slow = indicators.get(\"ema_slow\")\n        if fast is None or slow is None or self._prev_fast is None:\n            self._prev_fast, self._prev_slow = fast, slow\n            return None\n\n        crossed_up = fast &gt; slow and self._prev_fast &lt;= self._prev_slow\n        self._prev_fast, self._prev_slow = fast, slow\n\n        if not positions and crossed_up:\n            return MarketOrder(\n                side=Side.LONG,\n                take_profit_pct=0.08,\n                stop_loss_pct=0.03,\n                breakeven_trigger_pct=0.02,   # activate at +2%\n                breakeven_lock_pct=0.005,     # move SL to +0.5%\n            )\n        return None\n\n\nengine = BacktestEngine(\n    strategy=BreakevenStrategy(),\n    data=CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n    config={\n        \"initial_equity\": 10_000,\n        \"indicators\": {\n            \"ema_fast\": {\"type\": \"ema\", \"period\": 15, \"timeframe\": \"30m\", \"source\": \"close\"},\n            \"ema_slow\": {\"type\": \"ema\", \"period\": 35, \"timeframe\": \"30m\", \"source\": \"close\"},\n        },\n    },\n)\nresults = engine.run()\nprint(results.summary())\n</code></pre>"},{"location":"cookbook/breakeven/#how-it-works","title":"How It Works","text":"<pre><code>Entry at $2,000 (LONG)\n  SL = $1,940 (3% below entry)\n  TP = $2,120 (6% above entry)\n  Breakeven trigger = $2,040 (+2%)\n  Breakeven lock = $2,010 (+0.5%)\n\nPrice rises to $2,045:\n  \u2192 Breakeven activated!\n  \u2192 SL moves from $1,940 to $2,010\n\nIf price reverses:\n  \u2192 Exit at $2,010 (BREAKEVEN reason)\n  \u2192 Small profit instead of full loss\n</code></pre>"},{"location":"cookbook/breakeven/#exit-breakdown","title":"Exit Breakdown","text":"<p>Breakeven exits show as <code>BREAKEVEN</code> in the exit breakdown:</p> <pre><code>Exit Breakdown:\n  BREAKEVEN              28 (58.3%)\n  STOP_LOSS              12 (25.0%)\n  TAKE_PROFIT             8 (16.7%)\n</code></pre>"},{"location":"cookbook/breakeven/#parameters","title":"Parameters","text":"Parameter Description Typical Value <code>breakeven_trigger_pct</code> Profit level that activates breakeven 0.02 (2%) <code>breakeven_lock_pct</code> Where SL moves to after activation 0.005 (0.5%) <p>The lock level must be less than the trigger level. Once activated, the breakeven is permanent for that position \u2014 the SL cannot move back down.</p>"},{"location":"cookbook/ema-crossover/","title":"EMA Crossover","text":"<p>A basic trend-following strategy: go long when a fast EMA crosses above a slow EMA, short on the opposite cross.</p>"},{"location":"cookbook/ema-crossover/#complete-example","title":"Complete Example","text":"<pre><code>from replaybt import BacktestEngine, CSVProvider, Strategy, MarketOrder, Side\n\n\nclass EMACrossover(Strategy):\n    def configure(self, config):\n        self._prev_fast = None\n        self._prev_slow = None\n\n    def on_bar(self, bar, indicators, positions):\n        fast = indicators.get(\"ema_fast\")\n        slow = indicators.get(\"ema_slow\")\n\n        # Wait for indicators to warm up\n        if fast is None or slow is None or self._prev_fast is None:\n            self._prev_fast, self._prev_slow = fast, slow\n            return None\n\n        # Detect crossover\n        crossed_up = fast &gt; slow and self._prev_fast &lt;= self._prev_slow\n        crossed_down = fast &lt; slow and self._prev_fast &gt;= self._prev_slow\n        self._prev_fast, self._prev_slow = fast, slow\n\n        if not positions:\n            if crossed_up:\n                return MarketOrder(\n                    side=Side.LONG,\n                    take_profit_pct=0.05,\n                    stop_loss_pct=0.03,\n                )\n            if crossed_down:\n                return MarketOrder(\n                    side=Side.SHORT,\n                    take_profit_pct=0.05,\n                    stop_loss_pct=0.03,\n                )\n        return None\n\n\nengine = BacktestEngine(\n    strategy=EMACrossover(),\n    data=CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n    config={\n        \"initial_equity\": 10_000,\n        \"indicators\": {\n            \"ema_fast\": {\"type\": \"ema\", \"period\": 15, \"source\": \"close\"},\n            \"ema_slow\": {\"type\": \"ema\", \"period\": 35, \"source\": \"close\"},\n        },\n    },\n)\nresults = engine.run()\nprint(results.summary())\n</code></pre>"},{"location":"cookbook/ema-crossover/#whats-happening","title":"What's Happening","text":"<ol> <li>Indicators \u2014 two EMAs computed on each 1m bar's close price</li> <li>Crossover detection \u2014 compare current vs previous EMA values</li> <li>Signal \u2014 <code>MarketOrder</code> returned on crossover, fills at next bar's open</li> <li>Exits \u2014 engine manages TP at +5% and SL at -3% automatically</li> </ol>"},{"location":"cookbook/ema-crossover/#multi-timeframe-variant","title":"Multi-Timeframe Variant","text":"<p>Compute EMAs on 30-minute bars instead of 1-minute:</p> <pre><code>config={\n    \"indicators\": {\n        \"ema_fast\": {\"type\": \"ema\", \"period\": 15, \"timeframe\": \"30m\", \"source\": \"close\"},\n        \"ema_slow\": {\"type\": \"ema\", \"period\": 35, \"timeframe\": \"30m\", \"source\": \"close\"},\n    },\n}\n</code></pre> <p>The strategy code stays the same. The engine resamples 1m bars into 30m bars and updates the EMAs every 30 minutes.</p>"},{"location":"cookbook/ema-crossover/#adding-a-trend-filter","title":"Adding a Trend Filter","text":"<p>Only take longs when the 1h EMA trend is bullish:</p> <pre><code>config={\n    \"indicators\": {\n        \"ema_fast\": {\"type\": \"ema\", \"period\": 15, \"timeframe\": \"30m\", \"source\": \"close\"},\n        \"ema_slow\": {\"type\": \"ema\", \"period\": 35, \"timeframe\": \"30m\", \"source\": \"close\"},\n        \"ema_fast_1h\": {\"type\": \"ema\", \"period\": 15, \"timeframe\": \"1h\", \"source\": \"close\"},\n        \"ema_slow_1h\": {\"type\": \"ema\", \"period\": 35, \"timeframe\": \"1h\", \"source\": \"close\"},\n    },\n}\n</code></pre> <pre><code>def on_bar(self, bar, indicators, positions):\n    fast = indicators.get(\"ema_fast\")\n    slow = indicators.get(\"ema_slow\")\n    fast_1h = indicators.get(\"ema_fast_1h\")\n    slow_1h = indicators.get(\"ema_slow_1h\")\n\n    if any(v is None for v in [fast, slow, fast_1h, slow_1h]):\n        self._prev_fast, self._prev_slow = fast, slow\n        return None\n\n    crossed_up = fast &gt; slow and self._prev_fast &lt;= self._prev_slow\n    self._prev_fast, self._prev_slow = fast, slow\n\n    # Only long when 1h trend is bullish\n    if not positions and crossed_up and fast_1h &gt; slow_1h:\n        return MarketOrder(side=Side.LONG, take_profit_pct=0.06, stop_loss_pct=0.03)\n    return None\n</code></pre>"},{"location":"cookbook/mean-reversion/","title":"Mean Reversion","text":"<p>An RSI-based mean reversion strategy: buy when RSI dips below oversold, sell when it rises above overbought.</p>"},{"location":"cookbook/mean-reversion/#complete-example","title":"Complete Example","text":"<pre><code>from replaybt import BacktestEngine, CSVProvider, Strategy, MarketOrder, Side\n\n\nclass RSIScalper(Strategy):\n    def configure(self, config):\n        self._prev_rsi = None\n\n    def on_bar(self, bar, indicators, positions):\n        rsi = indicators.get(\"rsi\")\n        if rsi is None:\n            return None\n\n        prev = self._prev_rsi\n        self._prev_rsi = rsi\n\n        if prev is None:\n            return None\n\n        if not positions:\n            # Long when RSI crosses below 25 (oversold)\n            if rsi &lt; 25 and prev &gt;= 25:\n                return MarketOrder(\n                    side=Side.LONG,\n                    take_profit_pct=0.04,\n                    stop_loss_pct=0.05,\n                )\n            # Short when RSI crosses above 75 (overbought)\n            if rsi &gt; 75 and prev &lt;= 75:\n                return MarketOrder(\n                    side=Side.SHORT,\n                    take_profit_pct=0.04,\n                    stop_loss_pct=0.05,\n                )\n        return None\n\n\nengine = BacktestEngine(\n    strategy=RSIScalper(),\n    data=CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n    config={\n        \"initial_equity\": 10_000,\n        \"skip_signal_on_close\": False,  # allow re-entry after exit\n        \"indicators\": {\n            \"rsi\": {\"type\": \"rsi\", \"period\": 7, \"method\": \"wilder\"},\n        },\n    },\n)\nresults = engine.run()\nprint(results.summary())\n</code></pre>"},{"location":"cookbook/mean-reversion/#key-differences-from-trend-following","title":"Key Differences from Trend Following","text":""},{"location":"cookbook/mean-reversion/#skip_signal_on_close-false","title":"skip_signal_on_close = False","text":"<p>Mean reversion strategies often want to re-enter immediately after an exit. Setting <code>skip_signal_on_close=False</code> allows <code>on_bar()</code> to run even on bars where a position just closed.</p> <pre><code>config = {\n    \"skip_signal_on_close\": False,  # re-entry on same bar as exit\n}\n</code></pre>"},{"location":"cookbook/mean-reversion/#rsi-method-wilders-vs-simple","title":"RSI Method: Wilder's vs Simple","text":"<pre><code># Wilder's exponential RSI (recommended for volatile assets)\n\"rsi\": {\"type\": \"rsi\", \"period\": 7, \"method\": \"wilder\"}\n\n# Simple rolling RSI\n\"rsi\": {\"type\": \"rsi\", \"period\": 7, \"method\": \"simple\"}\n</code></pre> <p>Wilder's RSI reacts faster to recent price changes due to exponential weighting. On volatile assets like meme coins, it generates different entry times that often catch more profitable mean reversion opportunities.</p>"},{"location":"cookbook/mean-reversion/#wider-sl-than-tp","title":"Wider SL Than TP","text":"<p>Mean reversion strategies typically use a wider stop loss than take profit. The idea is that most entries are near extremes and will revert, but you need room for the occasional continuation move:</p> <pre><code>MarketOrder(\n    side=Side.LONG,\n    take_profit_pct=0.04,   # 4% TP (tight \u2014 capture the reversion)\n    stop_loss_pct=0.05,     # 5% SL (wider \u2014 tolerate noise)\n)\n</code></pre>"},{"location":"cookbook/mean-reversion/#adaptive-tpsl-with-volatility-regime","title":"Adaptive TP/SL with Volatility Regime","text":"<p>Adjust TP/SL based on recent volatility:</p> <pre><code>class AdaptiveScalper(Strategy):\n    def configure(self, config):\n        self._prev_rsi = None\n\n    def on_bar(self, bar, indicators, positions):\n        rsi = indicators.get(\"rsi\")\n        atr = indicators.get(\"atr\")\n\n        if rsi is None or atr is None:\n            self._prev_rsi = rsi\n            return None\n\n        prev = self._prev_rsi\n        self._prev_rsi = rsi\n\n        if prev is None or positions:\n            return None\n\n        # High vol \u2192 wide TP/SL, low vol \u2192 tight TP/SL\n        vol_ratio = atr / bar.close\n        if vol_ratio &gt; 0.0012:  # high volatility\n            tp, sl = 0.04, 0.05\n        else:\n            tp, sl = 0.025, 0.03\n\n        if rsi &lt; 25 and prev &gt;= 25:\n            return MarketOrder(side=Side.LONG, take_profit_pct=tp, stop_loss_pct=sl)\n        if rsi &gt; 75 and prev &lt;= 75:\n            return MarketOrder(side=Side.SHORT, take_profit_pct=tp, stop_loss_pct=sl)\n        return None\n</code></pre>"},{"location":"cookbook/multi-asset/","title":"Multi-Asset","text":"<p>Run the same strategy on multiple symbols in a time-synchronized loop. <code>MultiAssetEngine</code> merges bars chronologically and produces portfolio-level metrics that capture correlated drawdowns.</p>"},{"location":"cookbook/multi-asset/#complete-example","title":"Complete Example","text":"<pre><code>from replaybt import MultiAssetEngine, CSVProvider, Strategy, MarketOrder, Side\n\n\nclass EMACrossover(Strategy):\n    def configure(self, config):\n        self._prev = {}\n\n    def on_bar(self, bar, indicators, positions):\n        sym = bar.symbol\n        fast = indicators.get(\"ema_fast\")\n        slow = indicators.get(\"ema_slow\")\n\n        prev = self._prev.get(sym)\n        self._prev[sym] = (fast, slow)\n\n        if fast is None or slow is None or prev is None:\n            return None\n        if prev[0] is None:\n            return None\n\n        crossed_up = fast &gt; slow and prev[0] &lt;= prev[1]\n\n        if not positions and crossed_up:\n            return MarketOrder(\n                side=Side.LONG,\n                take_profit_pct=0.05,\n                stop_loss_pct=0.03,\n            )\n        return None\n\n\nengine = MultiAssetEngine(\n    strategy=EMACrossover(),\n    assets={\n        \"ETH\": CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n        \"SOL\": CSVProvider(\"SOL_1m.csv\", symbol_name=\"SOL\"),\n    },\n    config={\n        \"initial_equity\": 10_000,   # per symbol\n        \"indicators\": {\n            \"ema_fast\": {\"type\": \"ema\", \"period\": 15, \"source\": \"close\"},\n            \"ema_slow\": {\"type\": \"ema\", \"period\": 35, \"source\": \"close\"},\n        },\n    },\n)\nresults = engine.run()\nprint(results.summary())        # combined + per-symbol\nprint(results.monthly_table())  # combined monthly breakdown\n</code></pre>"},{"location":"cookbook/multi-asset/#per-symbol-config","title":"Per-Symbol Config","text":"<p>Override indicators, sizing, or other config per symbol:</p> <pre><code>config = {\n    \"initial_equity\": 10_000,\n    \"indicators\": {\n        \"ema_fast\": {\"type\": \"ema\", \"period\": 15, \"source\": \"close\"},\n        \"ema_slow\": {\"type\": \"ema\", \"period\": 35, \"source\": \"close\"},\n    },\n    \"symbol_configs\": {\n        \"ETH\": {\n            \"indicators\": {\n                \"ema_fast\": {\"type\": \"ema\", \"period\": 10, \"source\": \"close\"},\n                \"ema_slow\": {\"type\": \"ema\", \"period\": 30, \"source\": \"close\"},\n            },\n        },\n        \"SUI\": {\n            \"default_size_usd\": 5_000,\n        },\n    },\n}\n</code></pre>"},{"location":"cookbook/multi-asset/#exposure-cap","title":"Exposure Cap","text":"<p>Limit total portfolio exposure across all symbols:</p> <pre><code>config = {\n    \"initial_equity\": 10_000,\n    \"max_total_exposure_usd\": 25_000,  # cap total open exposure\n    # ...\n}\n</code></pre> <p>When the cap is reached, new orders are rejected until existing positions close.</p>"},{"location":"cookbook/multi-asset/#using-barsymbol","title":"Using bar.symbol","text":"<p>In a multi-asset strategy, <code>bar.symbol</code> tells you which asset the current bar belongs to. Positions are isolated per symbol.</p> <pre><code>def on_bar(self, bar, indicators, positions):\n    # bar.symbol == \"ETH\" or \"SOL\" etc.\n    # positions = only positions for this symbol\n    pass\n</code></pre>"},{"location":"cookbook/multi-asset/#results","title":"Results","text":"<p><code>MultiAssetResults</code> provides:</p> <pre><code># Combined metrics\nresults.combined_net_pnl          # total PnL across all symbols\nresults.combined_max_drawdown_pct  # portfolio-level drawdown\nresults.combined_win_rate\nresults.combined_total_trades\n\n# Per-symbol results\neth = results.per_symbol[\"ETH\"]   # BacktestResults\nsol = results.per_symbol[\"SOL\"]   # BacktestResults\nprint(eth.summary())\n\n# Combined equity curve\nresults.combined_equity_curve     # [(datetime, equity), ...]\n</code></pre> <p>Note</p> <p>Combined max drawdown captures correlated losses across symbols. Running separate <code>BacktestEngine</code> instances would understate the true portfolio drawdown.</p>"},{"location":"cookbook/rl-agent/","title":"RL Agent","text":"<p><code>StepEngine</code> provides a gym-like <code>step(action)</code> / <code>reset()</code> interface for reinforcement learning agents.</p>"},{"location":"cookbook/rl-agent/#complete-example","title":"Complete Example","text":"<pre><code>from replaybt import StepEngine, CSVProvider, MarketOrder, Side\n\n\ndef simple_agent(obs):\n    \"\"\"Trivial agent: go long when no position.\"\"\"\n    if not obs.positions:\n        return MarketOrder(\n            side=Side.LONG,\n            take_profit_pct=0.02,\n            stop_loss_pct=0.01,\n        )\n    return None\n\n\nenv = StepEngine(\n    data=CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n    config={\n        \"initial_equity\": 10_000,\n        \"indicators\": {\n            \"ema_fast\": {\"type\": \"ema\", \"period\": 5, \"source\": \"close\"},\n        },\n    },\n)\n\nobs = env.reset()\ntotal_reward = 0.0\n\nwhile not obs.done:\n    action = simple_agent(obs)\n    result = env.step(action)\n    obs = result.observation\n    total_reward += result.reward\n\n    if result.done:\n        break\n\nprint(f\"Steps: {obs.step_count}, Reward: {total_reward:.2f}\")\nprint(f\"Final equity: ${obs.equity:,.2f}\")\n</code></pre>"},{"location":"cookbook/rl-agent/#stepobservation","title":"StepObservation","text":"<p>Available on every step:</p> <pre><code>obs.bar          # current Bar (timestamp, OHLCV, symbol)\nobs.indicators   # dict of indicator values\nobs.positions    # list of open Position objects\nobs.equity       # current portfolio equity\nobs.step_count   # number of steps taken\nobs.done         # True if data is exhausted\n</code></pre>"},{"location":"cookbook/rl-agent/#stepresult","title":"StepResult","text":"<p>Returned by <code>step()</code>:</p> <pre><code>result.observation  # StepObservation (next state)\nresult.reward       # float \u2014 PnL change this step\nresult.done         # bool \u2014 episode finished\nresult.info         # dict \u2014 metadata\n</code></pre>"},{"location":"cookbook/rl-agent/#actions","title":"Actions","text":"<p>Pass an <code>Order</code> or <code>None</code>:</p> <pre><code># Do nothing\nresult = env.step(None)\n\n# Enter a position\nresult = env.step(MarketOrder(side=Side.LONG, take_profit_pct=0.03))\n\n# Place a limit order\nresult = env.step(LimitOrder(side=Side.LONG, limit_price=2300.0))\n</code></pre>"},{"location":"cookbook/rl-agent/#episode-loop","title":"Episode Loop","text":"<pre><code>for episode in range(100):\n    obs = env.reset()\n    episode_reward = 0.0\n\n    while not obs.done:\n        # Your RL policy here\n        action = policy(obs)\n        result = env.step(action)\n        obs = result.observation\n        episode_reward += result.reward\n\n    print(f\"Episode {episode}: reward={episode_reward:.2f}\")\n</code></pre>"},{"location":"cookbook/rl-agent/#with-a-custom-strategy","title":"With a Custom Strategy","text":"<p>You can also pass a <code>Strategy</code> to the <code>StepEngine</code> to handle indicator-based signals while using the step interface for observation:</p> <pre><code>env = StepEngine(\n    data=CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n    config={\"initial_equity\": 10_000},\n    strategy=MyStrategy(),\n)\n</code></pre> <p>When a strategy is provided, calling <code>env.step(None)</code> lets the strategy generate signals via <code>on_bar()</code>.</p>"},{"location":"cookbook/rl-agent/#building-feature-vectors","title":"Building Feature Vectors","text":"<p>Use <code>obs.indicators</code> and <code>obs.bar</code> to build feature vectors for your RL model:</p> <pre><code>import numpy as np\n\ndef obs_to_features(obs):\n    bar = obs.bar\n    return np.array([\n        bar.close,\n        bar.volume,\n        obs.indicators.get(\"ema_fast\") or 0,\n        obs.indicators.get(\"rsi\") or 50,\n        obs.equity / 10_000,  # normalized equity\n        1.0 if obs.positions else 0.0,\n    ])\n</code></pre>"},{"location":"cookbook/scale-in/","title":"Scale-In","text":"<p>Add to an existing position at a better price. replaybt supports two methods: DCA (limit order at a fixed dip) and signal-based (second entry on a new signal).</p>"},{"location":"cookbook/scale-in/#dca-scale-in","title":"DCA Scale-In","text":"<p>Place a limit order to buy more if price dips after entry:</p> <pre><code>from replaybt import Strategy, MarketOrder, LimitOrder, Side, CancelPendingLimitsOrder\n\n\nclass DCAStrategy(Strategy):\n    def configure(self, config):\n        self._prev_rsi = None\n\n    def on_bar(self, bar, indicators, positions):\n        rsi = indicators.get(\"rsi\")\n        prev = self._prev_rsi\n        self._prev_rsi = rsi\n        if rsi is None or prev is None:\n            return None\n\n        if not positions and rsi &lt; 25 and prev &gt;= 25:\n            return MarketOrder(\n                side=Side.LONG,\n                take_profit_pct=0.04,\n                stop_loss_pct=0.05,\n            )\n        return None\n\n    def on_fill(self, fill):\n        if fill.is_entry:\n            # Scale in at -0.5% from entry\n            dip_price = fill.price * 0.995\n            return LimitOrder(\n                side=fill.side,\n                limit_price=dip_price,\n                merge_position=True,   # merge into existing position\n                timeout_bars=120,      # cancel after 120 bars (2 hours)\n                size_usd=fill.size_usd * 0.5,  # 50% of main size\n            )\n        return None\n\n    def on_exit(self, fill, trade):\n        # Cancel pending scale-in when position closes\n        return CancelPendingLimitsOrder()\n</code></pre>"},{"location":"cookbook/scale-in/#how-merge_position-works","title":"How merge_position Works","text":"<p>When <code>merge_position=True</code>, the limit order doesn't open a new position. Instead, it merges into the existing one:</p> <ul> <li>Entry price becomes the weighted average of both fills</li> <li>Position size increases</li> <li>SL/TP levels recalculate from the new average entry</li> </ul>"},{"location":"cookbook/scale-in/#timeout","title":"Timeout","text":"<p><code>timeout_bars=120</code> means the limit order is canceled after 120 bars if not filled. Set <code>timeout_bars=0</code> for no timeout.</p>"},{"location":"cookbook/scale-in/#min_positions","title":"min_positions","text":"<p>Use <code>min_positions=1</code> to ensure the limit order only fills when a position already exists:</p> <pre><code>LimitOrder(\n    side=fill.side,\n    limit_price=dip_price,\n    merge_position=True,\n    min_positions=1,  # only fill if at least 1 position exists\n)\n</code></pre>"},{"location":"cookbook/scale-in/#signal-based-scale-in","title":"Signal-Based Scale-In","text":"<p>Enter a second position on a new RSI signal in the same direction:</p> <pre><code>class SignalScaleIn(Strategy):\n    def configure(self, config):\n        self._prev_rsi = None\n\n    def on_bar(self, bar, indicators, positions):\n        rsi = indicators.get(\"rsi\")\n        prev = self._prev_rsi\n        self._prev_rsi = rsi\n        if rsi is None or prev is None:\n            return None\n\n        if rsi &lt; 25 and prev &gt;= 25:\n            if not positions:\n                return MarketOrder(\n                    side=Side.LONG,\n                    take_profit_pct=0.04,\n                    stop_loss_pct=0.05,\n                )\n            # Already have a position \u2014 scale in with another signal\n            elif len(positions) == 1 and positions[0].is_long:\n                return MarketOrder(\n                    side=Side.LONG,\n                    take_profit_pct=0.04,\n                    stop_loss_pct=0.05,\n                    size_usd=5000,  # smaller second entry\n                )\n        return None\n</code></pre> <p>Note</p> <p>For signal-based scale-in with <code>max_positions=1</code>, you need <code>merge_position=True</code> on a <code>LimitOrder</code> instead, or increase <code>max_positions</code> in the engine config.</p>"},{"location":"cookbook/scale-in/#engine-config-for-scale-in","title":"Engine Config for Scale-In","text":"<pre><code>config = {\n    \"initial_equity\": 10_000,\n    \"max_positions\": 1,       # merge into single position\n    \"default_size_usd\": 10_000,\n}\n</code></pre> <p>With <code>max_positions=1</code> and <code>merge_position=True</code>, the engine merges additional fills into the existing position rather than rejecting them.</p>"},{"location":"cookbook/trailing-stop/","title":"Trailing Stop","text":"<p>A stop that follows price as it moves in your favor, locking in profits from large moves.</p>"},{"location":"cookbook/trailing-stop/#complete-example","title":"Complete Example","text":"<pre><code>from replaybt import BacktestEngine, CSVProvider, Strategy, MarketOrder, Side\n\n\nclass TrailingStopStrategy(Strategy):\n    def configure(self, config):\n        self._prev_fast = self._prev_slow = None\n\n    def on_bar(self, bar, indicators, positions):\n        fast = indicators.get(\"ema_fast\")\n        slow = indicators.get(\"ema_slow\")\n        if fast is None or slow is None or self._prev_fast is None:\n            self._prev_fast, self._prev_slow = fast, slow\n            return None\n\n        crossed_up = fast &gt; slow and self._prev_fast &lt;= self._prev_slow\n        self._prev_fast, self._prev_slow = fast, slow\n\n        if not positions and crossed_up:\n            return MarketOrder(\n                side=Side.LONG,\n                stop_loss_pct=0.05,                  # safety SL at 5%\n                trailing_stop_pct=0.02,              # trail 2% below peak\n                trailing_stop_activation_pct=0.03,   # activate after +3%\n            )\n        return None\n\n\nengine = BacktestEngine(\n    strategy=TrailingStopStrategy(),\n    data=CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n    config={\n        \"initial_equity\": 10_000,\n        \"indicators\": {\n            \"ema_fast\": {\"type\": \"ema\", \"period\": 15, \"source\": \"close\"},\n            \"ema_slow\": {\"type\": \"ema\", \"period\": 35, \"source\": \"close\"},\n        },\n    },\n)\nresults = engine.run()\nprint(results.summary())\n</code></pre>"},{"location":"cookbook/trailing-stop/#how-it-works","title":"How It Works","text":"<pre><code>Entry at $2,000 (LONG)\n  Safety SL = $1,900 (5%)\n  Trail activates at $2,060 (+3%)\n  Trail distance = 2%\n\nPrice path:\n  $2,000 \u2192 $2,060: trail activates, trail stop = $2,018.80\n  $2,060 \u2192 $2,100: trail stop moves up to $2,058.00\n  $2,100 \u2192 $2,150: trail stop moves up to $2,107.00\n  $2,150 \u2192 $2,110: trail stop at $2,107.00 \u2014 EXIT at $2,107\n\nProfit: +5.35% (vs 8% if you'd used a fixed TP at $2,160)\nBut captures most of a +7.5% move without predicting the top\n</code></pre>"},{"location":"cookbook/trailing-stop/#parameters","title":"Parameters","text":"Parameter Description Typical Value <code>trailing_stop_pct</code> Distance from peak (LONG) or trough (SHORT) 0.02 (2%) <code>trailing_stop_activation_pct</code> Minimum profit to activate trailing 0.03 (3%)"},{"location":"cookbook/trailing-stop/#with-fixed-tp","title":"With Fixed TP","text":"<p>You can combine a trailing stop with a fixed take profit:</p> <pre><code>MarketOrder(\n    side=Side.LONG,\n    take_profit_pct=0.10,                # cap at +10%\n    stop_loss_pct=0.05,                  # safety SL\n    trailing_stop_pct=0.02,              # trail 2%\n    trailing_stop_activation_pct=0.04,   # activate at +4%\n)\n</code></pre> <p>Whichever triggers first (fixed TP or trailing stop) closes the position.</p>"},{"location":"cookbook/trailing-stop/#without-activation-threshold","title":"Without Activation Threshold","text":"<p>Set <code>trailing_stop_activation_pct=0</code> to start trailing immediately from entry:</p> <pre><code>MarketOrder(\n    side=Side.LONG,\n    trailing_stop_pct=0.03,\n    trailing_stop_activation_pct=0.0,  # active from bar 1\n)\n</code></pre> <p>Warning</p> <p>Immediate trailing can trigger premature exits in choppy markets. An activation threshold gives the trade room to develop before the trail starts.</p>"},{"location":"data/","title":"Data","text":"<p>replaybt works with any source of OHLCV bars. Data providers are iterators that yield <code>Bar</code> objects \u2014 implement one method and plug in any data source.</p>"},{"location":"data/#provider-types","title":"Provider Types","text":"Provider Source Install CSVProvider CSV or Parquet files included BinanceProvider Binance API <code>pip install replaybt[data]</code> BybitProvider Bybit API <code>pip install replaybt[data]</code> CachedProvider Wraps any provider with caching included ValidatedProvider Wraps any provider with quality checks included ReplayProvider Nx speed replay for debugging included HyperliquidProvider Live Hyperliquid stream <code>pip install replaybt[live]</code> LighterProvider Live Lighter stream <code>pip install replaybt[live]</code>"},{"location":"data/#expected-data-format","title":"Expected Data Format","text":"<p>All providers must yield <code>Bar</code> objects with:</p> Field Type Description <code>timestamp</code> <code>datetime</code> Bar open time <code>open</code> <code>float</code> Open price <code>high</code> <code>float</code> High price <code>low</code> <code>float</code> Low price <code>close</code> <code>float</code> Close price <code>volume</code> <code>float</code> Volume <code>symbol</code> <code>str</code> Asset symbol <code>timeframe</code> <code>str</code> Bar timeframe (e.g., <code>\"1m\"</code>)"},{"location":"data/#custom-provider","title":"Custom Provider","text":"<p>Implement <code>DataProvider</code> to use any data source:</p> <pre><code>from replaybt import DataProvider, Bar\n\nclass MyProvider(DataProvider):\n    def __init__(self, data):\n        self._data = data\n\n    def __iter__(self):\n        for row in self._data:\n            yield Bar(\n                timestamp=row[\"time\"],\n                open=row[\"o\"],\n                high=row[\"h\"],\n                low=row[\"l\"],\n                close=row[\"c\"],\n                volume=row[\"v\"],\n                symbol=\"MY_ASSET\",\n            )\n\n    def symbol(self):\n        return \"MY_ASSET\"\n\n    def timeframe(self):\n        return \"1m\"\n</code></pre>"},{"location":"data/caching/","title":"Caching","text":"<p><code>CachedProvider</code> wraps any data provider and stores bars in memory after the first iteration. Useful for parameter sweeps where you run the same data multiple times.</p>"},{"location":"data/caching/#usage","title":"Usage","text":"<pre><code>from replaybt import CachedProvider, CSVProvider\n\ndata = CachedProvider(CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"))\n\n# First iteration: reads from disk, caches in memory\nengine1 = BacktestEngine(strategy=Strategy1(), data=data, config=config)\nresults1 = engine1.run()\n\n# Second iteration: reads from memory (fast)\ndata.reset()\nengine2 = BacktestEngine(strategy=Strategy2(), data=data, config=config)\nresults2 = engine2.run()\n</code></pre>"},{"location":"data/caching/#with-exchange-fetchers","title":"With Exchange Fetchers","text":"<p>Especially useful with API-based providers to avoid redundant network calls:</p> <pre><code>from replaybt import CachedProvider, BinanceProvider\n\ndata = CachedProvider(\n    BinanceProvider(\"ETHUSDT\", start=\"2024-01-01\", end=\"2024-12-31\")\n)\n\n# First run fetches from Binance API\n# Subsequent runs use cached bars\n</code></pre>"},{"location":"data/caching/#in-parameter-sweeps","title":"In Parameter Sweeps","text":"<p><code>ParameterSweep</code> handles caching internally \u2014 you don't need to wrap your provider manually:</p> <pre><code>from replaybt.optimize.sweep import ParameterSweep\n\nsweep = ParameterSweep(\n    strategy_class=MyStrategy,\n    data=CSVProvider(\"ETH_1m.csv\"),  # loaded once, shared across workers\n    base_config=config,\n    param_grid=grid,\n)\n</code></pre>"},{"location":"data/csv-loading/","title":"CSV &amp; Parquet Loading","text":"<p><code>CSVProvider</code> loads OHLCV data from CSV or Parquet files.</p>"},{"location":"data/csv-loading/#basic-usage","title":"Basic Usage","text":"<pre><code>from replaybt import CSVProvider\n\ndata = CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\")\n</code></pre>"},{"location":"data/csv-loading/#expected-columns","title":"Expected Columns","text":"Column Required Type <code>timestamp</code> yes datetime string or unix timestamp <code>open</code> yes float <code>high</code> yes float <code>low</code> yes float <code>close</code> yes float <code>volume</code> yes float <p>Example CSV:</p> <pre><code>timestamp,open,high,low,close,volume\n2024-01-01 00:00:00,2300.50,2301.20,2299.80,2300.90,125.5\n2024-01-01 00:01:00,2300.90,2302.00,2300.50,2301.80,98.3\n</code></pre>"},{"location":"data/csv-loading/#parameters","title":"Parameters","text":"<pre><code>CSVProvider(\n    path=\"ETH_1m.csv\",          # path to CSV or Parquet file\n    symbol_name=\"ETH\",          # symbol name for Bar objects\n    timeframe=\"1m\",             # bar timeframe\n    start=\"2024-01-01\",         # optional start date filter\n    end=\"2024-12-31\",           # optional end date filter\n    timestamp_col=\"timestamp\",  # name of timestamp column\n)\n</code></pre>"},{"location":"data/csv-loading/#date-filtering","title":"Date Filtering","text":"<p>Filter to a specific date range:</p> <pre><code># Full year 2024\ndata = CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\", start=\"2024-01-01\", end=\"2024-12-31\")\n\n# Last 6 months\ndata = CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\", start=\"2024-07-01\")\n</code></pre>"},{"location":"data/csv-loading/#parquet-files","title":"Parquet Files","text":"<p>CSVProvider auto-detects Parquet files by extension:</p> <pre><code>data = CSVProvider(\"ETH_1m.parquet\", symbol_name=\"ETH\")\n</code></pre> <p>Parquet loads faster than CSV for large datasets.</p>"},{"location":"data/csv-loading/#custom-timestamp-column","title":"Custom Timestamp Column","text":"<p>If your timestamp column has a different name:</p> <pre><code>data = CSVProvider(\"data.csv\", timestamp_col=\"time\")\n</code></pre>"},{"location":"data/csv-loading/#reset","title":"Reset","text":"<p>Call <code>reset()</code> to re-iterate from the beginning (useful in parameter sweeps):</p> <pre><code>data = CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\")\n\n# First backtest\nengine1 = BacktestEngine(strategy=MyStrategy(), data=data, config=config)\nresults1 = engine1.run()\n\n# Reset for second backtest\ndata.reset()\nengine2 = BacktestEngine(strategy=OtherStrategy(), data=data, config=config)\nresults2 = engine2.run()\n</code></pre>"},{"location":"data/exchange-fetchers/","title":"Exchange Fetchers","text":"<p>Fetch historical OHLCV data directly from exchange APIs.</p> <pre><code>pip install replaybt[data]  # requires requests\n</code></pre>"},{"location":"data/exchange-fetchers/#binanceprovider","title":"BinanceProvider","text":"<pre><code>from replaybt import BinanceProvider\n\ndata = BinanceProvider(\n    symbol=\"ETHUSDT\",\n    timeframe=\"1m\",\n    start=\"2024-01-01\",\n    end=\"2024-12-31\",\n)\n\n# Use like any other provider\nengine = BacktestEngine(strategy=my_strategy, data=data, config=config)\nresults = engine.run()\n</code></pre>"},{"location":"data/exchange-fetchers/#parameters","title":"Parameters","text":"<pre><code>BinanceProvider(\n    symbol=\"ETHUSDT\",       # Binance trading pair\n    timeframe=\"1m\",         # \"1m\", \"5m\", \"15m\", \"30m\", \"1h\", \"4h\", \"1d\"\n    start=\"2024-01-01\",     # start date (inclusive)\n    end=\"2024-12-31\",       # end date (inclusive)\n)\n</code></pre>"},{"location":"data/exchange-fetchers/#bybitprovider","title":"BybitProvider","text":"<pre><code>from replaybt import BybitProvider\n\ndata = BybitProvider(\n    symbol=\"ETHUSDT\",\n    timeframe=\"1m\",\n    start=\"2024-01-01\",\n    end=\"2024-12-31\",\n)\n</code></pre>"},{"location":"data/exchange-fetchers/#parameters_1","title":"Parameters","text":"<p>Same interface as <code>BinanceProvider</code>:</p> <pre><code>BybitProvider(\n    symbol=\"ETHUSDT\",       # Bybit trading pair\n    timeframe=\"1m\",         # \"1m\", \"5m\", \"15m\", \"30m\", \"1h\", \"4h\", \"1d\"\n    start=\"2024-01-01\",     # start date (inclusive)\n    end=\"2024-12-31\",       # end date (inclusive)\n)\n</code></pre>"},{"location":"data/exchange-fetchers/#rate-limits","title":"Rate Limits","text":"<p>Both providers handle pagination automatically. For large date ranges with 1m data, fetching may take a few minutes due to API rate limits.</p>"},{"location":"data/exchange-fetchers/#combining-with-cachedprovider","title":"Combining with CachedProvider","text":"<p>Avoid re-fetching on repeated runs:</p> <pre><code>from replaybt import CachedProvider\n\ndata = CachedProvider(\n    BinanceProvider(\"ETHUSDT\", start=\"2024-01-01\", end=\"2024-12-31\")\n)\n</code></pre> <p>The first run fetches from the API; subsequent iterations use the cached bars.</p>"},{"location":"data/live-providers/","title":"Live Providers","text":"<p>Stream real-time data from exchanges for live trading or replay at accelerated speed.</p> <pre><code>pip install replaybt[live]  # requires aiohttp, websockets\n</code></pre>"},{"location":"data/live-providers/#replayprovider","title":"ReplayProvider","text":"<p>Replay historical data at Nx wall-clock speed. Useful for visual debugging or demo purposes.</p> <pre><code>from replaybt import ReplayProvider, CSVProvider\n\ndata = ReplayProvider(\n    inner=CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n    speed=60,  # 60x speed: 1m bar = 1 second wall-clock\n)\n\nfor bar in data:\n    print(f\"{bar.timestamp} close={bar.close}\")\n    # Each bar arrives 1 second apart at 60x speed\n</code></pre>"},{"location":"data/live-providers/#speed-settings","title":"Speed Settings","text":"Speed Meaning <code>0</code> Instant (no delay) <code>1</code> Real-time (1m bar = 60s delay) <code>60</code> 60x speed (1m bar = 1s delay) <code>3600</code> 3600x speed (1h of data per second)"},{"location":"data/live-providers/#callback","title":"Callback","text":"<p>Execute a function on each bar:</p> <pre><code>data = ReplayProvider(\n    inner=CSVProvider(\"ETH_1m.csv\"),\n    speed=60,\n    on_bar=lambda bar: print(f\"Price: {bar.close}\"),\n)\n</code></pre>"},{"location":"data/live-providers/#hyperliquidprovider","title":"HyperliquidProvider","text":"<p>Async real-time data streaming from Hyperliquid exchange:</p> <pre><code>from replaybt import HyperliquidProvider\n\nprovider = HyperliquidProvider()\n</code></pre>"},{"location":"data/live-providers/#lighterprovider","title":"LighterProvider","text":"<p>Async real-time data streaming from Lighter exchange:</p> <pre><code>from replaybt import LighterProvider\n\nprovider = LighterProvider()\n</code></pre>"},{"location":"data/live-providers/#asyncdataprovider","title":"AsyncDataProvider","text":"<p>Base class for building custom async live data providers:</p> <pre><code>from replaybt import AsyncDataProvider\n\nclass MyLiveProvider(AsyncDataProvider):\n    # Implement async data streaming\n    ...\n</code></pre> <p>Note</p> <p>Live providers are designed for integration with live trading bots. For backtesting, use <code>CSVProvider</code> or exchange fetchers with historical data.</p>"},{"location":"data/validation/","title":"Data Validation","text":"<p>Catch data quality issues before they corrupt your backtest results.</p>"},{"location":"data/validation/#datavalidator","title":"DataValidator","text":"<p>Validate a pandas DataFrame:</p> <pre><code>import pandas as pd\nfrom replaybt import DataValidator\n\ndf = pd.read_csv(\"ETH_1m.csv\", parse_dates=[\"timestamp\"])\nvalidator = DataValidator(df, symbol=\"ETH\", timeframe=\"1m\")\n\nissues = validator.validate()\nprint(validator.report())\n</code></pre>"},{"location":"data/validation/#checks-performed","title":"Checks Performed","text":"Check Severity What it catches Missing columns ERROR OHLCV columns not present Duplicate timestamps ERROR Same timestamp appears twice Time gaps WARNING Missing bars in the sequence OHLC violations WARNING High &lt; Low, Open/Close outside High/Low range Negative values ERROR Negative prices or volume Zero values WARNING Zero prices (volume can be zero)"},{"location":"data/validation/#dataissue","title":"DataIssue","text":"<p>Each issue returned has:</p> <pre><code>issue.severity   # \"ERROR\", \"WARNING\", \"INFO\"\nissue.check      # issue type identifier\nissue.message    # human-readable description\nissue.row_index  # row where issue occurs (if applicable)\nissue.timestamp  # timestamp of the row (if applicable)\n</code></pre>"},{"location":"data/validation/#validatedprovider","title":"ValidatedProvider","text":"<p>Wrap any provider to validate bars on the fly:</p> <pre><code>from replaybt import ValidatedProvider, CSVProvider\n\ndata = ValidatedProvider(\n    inner=CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n    stop_on_error=False,  # True = raise on first ERROR\n)\n\n# Issues are logged as bars are yielded\nengine = BacktestEngine(strategy=my_strategy, data=data, config=config)\nresults = engine.run()\n</code></pre>"},{"location":"data/validation/#convenience-functions","title":"Convenience Functions","text":"<pre><code>from replaybt import validate_dataframe, validate_provider\n\n# Validate a DataFrame directly\nissues = validate_dataframe(df, symbol=\"ETH\", timeframe=\"1m\")\n\n# Validate a provider\nissues = validate_provider(CSVProvider(\"ETH_1m.csv\"), symbol=\"ETH\")\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#install","title":"Install","text":"<pre><code>pip install replaybt\n</code></pre>"},{"location":"getting-started/#prepare-data","title":"Prepare Data","text":"<p>replaybt expects 1-minute OHLCV data in CSV or Parquet format with columns: <code>timestamp</code>, <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code>, <code>volume</code>.</p> <pre><code>timestamp,open,high,low,close,volume\n2024-01-01 00:00:00,2300.50,2301.20,2299.80,2300.90,125.5\n2024-01-01 00:01:00,2300.90,2302.00,2300.50,2301.80,98.3\n...\n</code></pre> <p>You can also fetch data directly from exchanges:</p> <pre><code>from replaybt import BinanceProvider\n\ndata = BinanceProvider(\"ETHUSDT\", start=\"2024-01-01\", end=\"2024-12-31\")\n</code></pre>"},{"location":"getting-started/#your-first-backtest","title":"Your First Backtest","text":"<pre><code>from replaybt import BacktestEngine, CSVProvider, Strategy, MarketOrder, Side\n\n\nclass EMACrossover(Strategy):\n    \"\"\"Go long when fast EMA crosses above slow EMA.\"\"\"\n\n    def configure(self, config):\n        self._prev_fast = self._prev_slow = None\n\n    def on_bar(self, bar, indicators, positions):\n        fast = indicators.get(\"ema_fast\")\n        slow = indicators.get(\"ema_slow\")\n\n        # Wait for indicators to warm up\n        if fast is None or slow is None or self._prev_fast is None:\n            self._prev_fast, self._prev_slow = fast, slow\n            return None\n\n        # Detect crossover\n        crossed_up = fast &gt; slow and self._prev_fast &lt;= self._prev_slow\n        crossed_down = fast &lt; slow and self._prev_fast &gt;= self._prev_slow\n        self._prev_fast, self._prev_slow = fast, slow\n\n        # Emit signal (fills at next bar's open)\n        if not positions:\n            if crossed_up:\n                return MarketOrder(\n                    side=Side.LONG,\n                    take_profit_pct=0.05,\n                    stop_loss_pct=0.03,\n                )\n            if crossed_down:\n                return MarketOrder(\n                    side=Side.SHORT,\n                    take_profit_pct=0.05,\n                    stop_loss_pct=0.03,\n                )\n        return None\n\n\nengine = BacktestEngine(\n    strategy=EMACrossover(),\n    data=CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n    config={\n        \"initial_equity\": 10_000,\n        \"indicators\": {\n            \"ema_fast\": {\"type\": \"ema\", \"period\": 15, \"source\": \"close\"},\n            \"ema_slow\": {\"type\": \"ema\", \"period\": 35, \"source\": \"close\"},\n        },\n    },\n)\nresults = engine.run()\nprint(results.summary())\n</code></pre>"},{"location":"getting-started/#understanding-the-output","title":"Understanding the Output","text":"<p><code>results.summary()</code> prints:</p> <pre><code>============================================================\n  Backtest Results: ETH\n============================================================\n  Net PnL:          $1,245.00 (+12.5%)\n  Max Drawdown:     8.3%\n  Total Trades:     47\n  Win Rate:         63.8%\n  Avg Win:          $89.50 (3.21%)\n  Avg Loss:         $52.30 (1.88%)\n  Profit Factor:    1.71\n  Total Fees:       $32.90\n  Initial Equity:   $10,000.00\n  Final Equity:     $11,245.00\n  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  Buy &amp; Hold:       +45.2%\n  Alpha:            -32.7%\n  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  Exit Breakdown:\n    BREAKEVEN              12 (25.5%)\n    STOP_LOSS              15 (31.9%)\n    TAKE_PROFIT            20 (42.6%)\n============================================================\n</code></pre> <p>Key metrics:</p> Metric What it means Net PnL Profit after all fees and slippage Max Drawdown Largest peak-to-trough equity decline Win Rate Percentage of trades that were profitable Profit Factor Gross profit / gross loss (&gt; 1 = profitable) Total Fees Sum of all slippage + taker/maker fees Alpha Strategy return minus buy-and-hold return"},{"location":"getting-started/#monthly-breakdown","title":"Monthly Breakdown","text":"<pre><code>print(results.monthly_table())\n</code></pre> <p>Shows per-month PnL, win rate, and trade count \u2014 useful for spotting regime-dependent performance.</p>"},{"location":"getting-started/#what-happens-under-the-hood","title":"What Happens Under the Hood","text":"<p>Every bar goes through four phases:</p> <ol> <li>Fill pending orders \u2014 market orders fill at this bar's open + slippage</li> <li>Check limit orders \u2014 pending limit orders checked for price-triggered fills</li> <li>Check exits \u2014 SL/TP checked against open (gap), then high/low (intra-bar)</li> <li>Call strategy \u2014 <code>on_bar()</code> runs with the completed bar, returned orders become pending</li> </ol> <p>This means your signal at bar T always fills at bar T+1's open. No look-ahead bias is possible.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Concepts \u2014 deep dive into the execution model</li> <li>Strategy Callbacks \u2014 <code>on_fill</code>, <code>on_exit</code>, <code>check_exits</code></li> <li>Cookbook \u2014 working recipes for common patterns</li> </ul>"},{"location":"optimization/","title":"Optimization","text":"<p>Tools for finding good parameters and testing their robustness.</p> Tool Purpose Parameter Sweep Parallel grid search across parameter combinations Walk-Forward Rolling train/test optimization Monte Carlo Randomized robustness analysis"},{"location":"optimization/#philosophy","title":"Philosophy","text":"<p>Optimization is dangerous. The best parameters on historical data are often the worst parameters going forward. replaybt provides optimization tools alongside validation tools to help you distinguish robust parameters from overfit ones.</p> <p>Recommended workflow:</p> <ol> <li>Sweep \u2014 find parameter regions that work</li> <li>Walk-forward \u2014 test if the best parameters are stable across time windows</li> <li>Monte Carlo \u2014 estimate the range of outcomes and probability of ruin</li> <li>OOS split \u2014 final blind validation on held-out data</li> </ol>"},{"location":"optimization/monte-carlo/","title":"Monte Carlo","text":"<p>Randomized simulation to estimate the range of possible outcomes from your trade history.</p>"},{"location":"optimization/monte-carlo/#complete-example","title":"Complete Example","text":"<pre><code>from replaybt import BacktestEngine, CSVProvider, MonteCarlo\n\n# Run backtest first\nengine = BacktestEngine(strategy=my_strategy, data=data, config=config)\nresults = engine.run()\n\n# Monte Carlo analysis\nmc = MonteCarlo(results, n_simulations=1000)\nmc_result = mc.run()\nprint(mc_result.summary())\n</code></pre>"},{"location":"optimization/monte-carlo/#what-it-does","title":"What It Does","text":"<p>Monte Carlo runs two types of simulations on your actual trade results:</p>"},{"location":"optimization/monte-carlo/#shuffle-permutation","title":"Shuffle (Permutation)","text":"<p>Randomly reorder the sequence of trades and replay them. This tests whether your results depend on the specific order of trades or are robust to any ordering.</p> <p>With 1,000 shuffles, you get a distribution of possible PnL outcomes and drawdowns from the same set of trades.</p>"},{"location":"optimization/monte-carlo/#bootstrap-resampling","title":"Bootstrap (Resampling)","text":"<p>Randomly sample trades with replacement to create synthetic trade sequences. This estimates confidence intervals for your performance metrics.</p>"},{"location":"optimization/monte-carlo/#montecarloresult","title":"MonteCarloResult","text":"<pre><code>mc_result = mc.run()\n\n# Shuffle results (trade order randomization)\nmc_result.shuffle_pnl_percentiles     # {5: $X, 25: $Y, 50: $Z, 75: $W, 95: $V}\nmc_result.shuffle_max_dd_mean         # average max drawdown\nmc_result.shuffle_max_dd_percentiles  # {5: X%, 50: Y%, 95: Z%}\n\n# Bootstrap results (resampled trades)\nmc_result.bootstrap_pnl_mean          # expected PnL\nmc_result.bootstrap_pnl_std           # PnL standard deviation\nmc_result.bootstrap_pnl_percentiles   # {5: $X, 25: $Y, 50: $Z, 75: $W, 95: $V}\nmc_result.bootstrap_max_dd_mean\nmc_result.bootstrap_max_dd_percentiles\n\n# Ruin probability\nmc_result.ruin_probability            # fraction of simulations that went to zero\n</code></pre>"},{"location":"optimization/monte-carlo/#interpreting-results","title":"Interpreting Results","text":"<pre><code>print(mc_result.summary())\n</code></pre> <p>Key things to look for:</p> Metric Good Sign Warning Sign Shuffle 5th percentile PnL Still positive Negative Ruin probability 0% &gt; 5% Bootstrap PnL std Small vs mean Larger than mean Shuffle DD 95th pct &lt; 25% &gt; 40%"},{"location":"optimization/monte-carlo/#parameters","title":"Parameters","text":"<pre><code>MonteCarlo(\n    results=backtest_results,  # BacktestResults from a completed backtest\n    n_simulations=1000,        # number of random simulations\n)\n</code></pre> <p>More simulations give tighter confidence intervals but take longer. 1,000 is usually sufficient.</p>"},{"location":"optimization/parameter-sweep/","title":"Parameter Sweep","text":"<p>Parallel grid search across parameter combinations using multiprocessing.</p>"},{"location":"optimization/parameter-sweep/#complete-example","title":"Complete Example","text":"<pre><code>from replaybt import CSVProvider, Strategy, MarketOrder, Side\nfrom replaybt.optimize.sweep import ParameterSweep\n\n\nclass EMACrossover(Strategy):\n    def configure(self, config):\n        self._prev_fast = self._prev_slow = None\n\n    def on_bar(self, bar, indicators, positions):\n        fast = indicators.get(\"ema_fast\")\n        slow = indicators.get(\"ema_slow\")\n        if fast is None or slow is None or self._prev_fast is None:\n            self._prev_fast, self._prev_slow = fast, slow\n            return None\n\n        crossed_up = fast &gt; slow and self._prev_fast &lt;= self._prev_slow\n        self._prev_fast, self._prev_slow = fast, slow\n\n        if not positions and crossed_up:\n            return MarketOrder(side=Side.LONG)\n        return None\n\n\nsweep = ParameterSweep(\n    strategy_class=EMACrossover,\n    data=CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n    base_config={\n        \"initial_equity\": 10_000,\n        \"indicators\": {\n            \"ema_fast\": {\"type\": \"ema\", \"period\": 5, \"source\": \"close\"},\n            \"ema_slow\": {\"type\": \"ema\", \"period\": 10, \"source\": \"close\"},\n        },\n    },\n    param_grid={\n        \"take_profit_pct\": [0.02, 0.04, 0.06, 0.08, 0.10],\n        \"stop_loss_pct\": [0.01, 0.02, 0.03, 0.04],\n    },\n    n_workers=10,\n)\n\nresults = sweep.run()\nprint(results.summary(top_n=10))\n</code></pre>"},{"location":"optimization/parameter-sweep/#parameters","title":"Parameters","text":"<pre><code>ParameterSweep(\n    strategy_class=MyStrategy,    # Strategy CLASS (not instance)\n    data=data_provider,           # DataProvider instance\n    base_config=config_dict,      # base engine config\n    param_grid={                  # parameters to sweep\n        \"take_profit_pct\": [0.04, 0.06, 0.08],\n        \"stop_loss_pct\": [0.02, 0.03, 0.04],\n    },\n    n_workers=10,                 # parallel workers (default: cpu_count)\n)\n</code></pre> <p>The sweep evaluates every combination of parameter values. With 5 TP values and 4 SL values, that's 20 combinations evaluated in parallel.</p>"},{"location":"optimization/parameter-sweep/#sweepresults","title":"SweepResults","text":""},{"location":"optimization/parameter-sweep/#topbottom-results","title":"Top/Bottom Results","text":"<pre><code>results = sweep.run()\n\n# Top 10 by net PnL\nbest = results.best(\"net_pnl\", n=10)\nfor combo in best:\n    print(f\"TP={combo['take_profit_pct']}, SL={combo['stop_loss_pct']} \u2192 ${combo['net_pnl']:,.0f}\")\n\n# Bottom 5\nworst = results.worst(\"net_pnl\", n=5)\n</code></pre>"},{"location":"optimization/parameter-sweep/#filter","title":"Filter","text":"<pre><code># Only combos where TP &gt;= 0.06\nfiltered = results.filter(take_profit_pct=0.06)\nprint(filtered.summary())\n</code></pre>"},{"location":"optimization/parameter-sweep/#dataframe-export","title":"DataFrame Export","text":"<pre><code>df = results.to_dataframe()\nprint(df.sort_values(\"net_pnl\", ascending=False).head(10))\n</code></pre>"},{"location":"optimization/parameter-sweep/#available-metrics","title":"Available Metrics","text":"<p>Each combo dict includes:</p> Key Description <code>net_pnl</code> Net profit/loss <code>net_return_pct</code> Return percentage <code>max_drawdown_pct</code> Maximum drawdown <code>total_trades</code> Number of trades <code>win_rate</code> Win rate percentage <code>profit_factor</code> Gross profit / gross loss <p>Plus all parameter keys from <code>param_grid</code>.</p>"},{"location":"optimization/parameter-sweep/#formatted-summary","title":"Formatted Summary","text":"<pre><code>print(results.summary(metric=\"net_pnl\", top_n=20))\n</code></pre> <p>Prints a table of the top 20 combinations sorted by the specified metric.</p>"},{"location":"optimization/walk-forward/","title":"Walk-Forward","text":"<p>Rolling walk-forward optimization: optimize parameters on a training window, then test on the next out-of-sample window. Repeat across the dataset.</p>"},{"location":"optimization/walk-forward/#complete-example","title":"Complete Example","text":"<pre><code>from replaybt import CSVProvider, Strategy, MarketOrder, Side\nfrom replaybt import WalkForward\n\n\nclass EMACrossover(Strategy):\n    def configure(self, config):\n        self._prev_fast = self._prev_slow = None\n\n    def on_bar(self, bar, indicators, positions):\n        fast = indicators.get(\"ema_fast\")\n        slow = indicators.get(\"ema_slow\")\n        if fast is None or slow is None or self._prev_fast is None:\n            self._prev_fast, self._prev_slow = fast, slow\n            return None\n\n        crossed_up = fast &gt; slow and self._prev_fast &lt;= self._prev_slow\n        self._prev_fast, self._prev_slow = fast, slow\n\n        if not positions and crossed_up:\n            return MarketOrder(side=Side.LONG)\n        return None\n\n\nwf = WalkForward(\n    strategy_class=EMACrossover,\n    data=CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n    base_config={\n        \"initial_equity\": 10_000,\n        \"indicators\": {\n            \"ema_fast\": {\"type\": \"ema\", \"period\": 5, \"source\": \"close\"},\n            \"ema_slow\": {\"type\": \"ema\", \"period\": 10, \"source\": \"close\"},\n        },\n    },\n    param_grid={\n        \"take_profit_pct\": [0.04, 0.06, 0.08],\n        \"stop_loss_pct\": [0.02, 0.03, 0.04],\n    },\n    n_windows=4,       # number of train/test windows\n    train_pct=0.60,    # 60% train, 40% test per window\n    metric=\"net_pnl\",  # optimize for net PnL\n    anchored=False,    # sliding windows (vs anchored)\n)\n\nresult = wf.run()\nprint(result.summary())\n</code></pre>"},{"location":"optimization/walk-forward/#parameters","title":"Parameters","text":"<pre><code>WalkForward(\n    strategy_class=MyStrategy,\n    data=data_provider,\n    base_config=config_dict,\n    param_grid=param_dict,\n    n_windows=4,          # number of train/test windows\n    train_pct=0.60,       # train fraction per window\n    metric=\"net_pnl\",     # metric to optimize on train\n    anchored=False,       # False=sliding, True=anchored\n    n_workers=10,         # parallel workers for sweep\n)\n</code></pre>"},{"location":"optimization/walk-forward/#sliding-vs-anchored","title":"Sliding vs Anchored","text":"<p>Sliding (default): each window is a fixed-size slice that moves forward.</p> <pre><code>Window 1: [====TRAIN====][==TEST==]\nWindow 2:       [====TRAIN====][==TEST==]\nWindow 3:             [====TRAIN====][==TEST==]\n</code></pre> <p>Anchored: training always starts from the beginning, growing larger.</p> <pre><code>Window 1: [====TRAIN====][==TEST==]\nWindow 2: [========TRAIN========][==TEST==]\nWindow 3: [============TRAIN============][==TEST==]\n</code></pre>"},{"location":"optimization/walk-forward/#walkforwardresult","title":"WalkForwardResult","text":"<pre><code>result = wf.run()\n\n# Aggregate OOS metrics\nresult.oos_net_pnl           # combined OOS PnL\nresult.oos_total_trades      # combined OOS trades\nresult.oos_win_rate          # combined OOS win rate\nresult.oos_max_drawdown_pct  # combined OOS max drawdown\n\n# Parameter stability\nresult.param_stability       # {param_name: [values per window]}\nresult.params_consistent     # True if same params chosen &gt;50% of windows\n\n# Per-window details\nfor w in result.windows:\n    print(f\"Window {w.window_index}: \"\n          f\"train PnL=${w.train_metrics['net_pnl']:,.0f}, \"\n          f\"test PnL=${w.test_result.net_pnl:,.0f}, \"\n          f\"params={w.best_params}\")\n</code></pre>"},{"location":"optimization/walk-forward/#interpreting-results","title":"Interpreting Results","text":"<ul> <li>params_consistent = True: the same parameters keep winning across windows. Good sign.</li> <li>params_consistent = False: optimal parameters change every window. Likely overfitting.</li> <li>OOS PnL negative: the strategy doesn't generalize. Reconsider the approach.</li> </ul>"},{"location":"strategy/","title":"Strategy","text":"<p>A strategy in replaybt is a class that receives completed bars and returns orders. The engine handles everything else \u2014 execution, slippage, fees, exits.</p>"},{"location":"strategy/#strategy-lifecycle","title":"Strategy Lifecycle","text":"<pre><code>Engine created\n\u2502\n\u251c\u2500 configure(config)          # once, before first bar\n\u2502\n\u251c\u2500 For each bar:\n\u2502  \u251c\u2500 (engine fills pending orders)\n\u2502  \u251c\u2500 (engine checks SL/TP/breakeven/trailing)\n\u2502  \u251c\u2500 check_exits(bar, positions)  # optional custom exit logic\n\u2502  \u2514\u2500 on_bar(bar, indicators, positions)  # emit signals\n\u2502      \u2502\n\u2502      \u251c\u2500 on_fill(fill)       # after entry fill (next bar)\n\u2502      \u2514\u2500 on_exit(fill, trade) # after position close\n\u2502\n\u2514\u2500 Engine returns BacktestResults\n</code></pre>"},{"location":"strategy/#pages","title":"Pages","text":"Page What you'll learn Callbacks <code>on_bar</code>, <code>on_fill</code>, <code>on_exit</code>, <code>check_exits</code> Declarative JSON-config strategy with no Python class Per-Symbol Config <code>StrategyConfig</code> defaults + per-symbol overrides Custom Exits Partial TP, trailing stops, breakeven, post-exit re-entry"},{"location":"strategy/callbacks/","title":"Strategy Callbacks","text":""},{"location":"strategy/callbacks/#on_bar-required","title":"on_bar (required)","text":"<p>Called with every completed bar. Return an <code>Order</code> to emit a signal, or <code>None</code>.</p> <pre><code>from replaybt import Strategy, MarketOrder, Side, Bar\nfrom typing import Dict, Any, List\n\nclass MyStrategy(Strategy):\n    def on_bar(\n        self,\n        bar: Bar,               # completed 1m bar\n        indicators: Dict[str, Any],  # current indicator values\n        positions: List,         # open positions\n    ):\n        ema = indicators.get(\"ema_fast\")\n        if ema is None:\n            return None\n\n        if not positions and bar.close &gt; ema:\n            return MarketOrder(\n                side=Side.LONG,\n                take_profit_pct=0.05,\n                stop_loss_pct=0.03,\n            )\n        return None\n</code></pre> <p>Arguments:</p> Arg Type Description <code>bar</code> <code>Bar</code> Current completed 1m bar with timestamp, OHLCV, symbol <code>indicators</code> <code>Dict[str, Any]</code> Values from configured indicators. <code>None</code> if not ready <code>positions</code> <code>List[Position]</code> Currently open positions for this symbol <p>Returns: <code>Order</code>, <code>List[Order]</code>, or <code>None</code></p>"},{"location":"strategy/callbacks/#configure","title":"configure","text":"<p>Called once before the first bar. Use it to initialize strategy state.</p> <pre><code>class MyStrategy(Strategy):\n    def configure(self, config: dict):\n        self._prev_fast = None\n        self._prev_slow = None\n        self._trade_count = 0\n</code></pre> <p>The <code>config</code> dict is the same dict passed to the engine constructor.</p>"},{"location":"strategy/callbacks/#on_fill","title":"on_fill","text":"<p>Called after an entry fill (or a merge fill for scale-in). Can return a <code>LimitOrder</code> for scale-in or a <code>MarketOrder</code>.</p> <pre><code>from replaybt import LimitOrder\n\nclass ScaleInStrategy(Strategy):\n    def on_fill(self, fill):\n        if fill.is_entry:\n            # Place a limit order to scale in at -0.5% from entry\n            dip_price = fill.price * (1 - 0.005) if fill.side == Side.LONG else fill.price * (1 + 0.005)\n            return LimitOrder(\n                side=fill.side,\n                limit_price=dip_price,\n                merge_position=True,  # merge into existing position\n                timeout_bars=120,\n            )\n        return None\n</code></pre> <p>Arguments:</p> Arg Type Description <code>fill</code> <code>Fill</code> The fill event with price, side, size, fees, <code>is_entry</code> flag <p>Returns: <code>Order</code> or <code>None</code></p>"},{"location":"strategy/callbacks/#on_exit","title":"on_exit","text":"<p>Called after a position closes. Can return an <code>Order</code> for immediate re-entry, a <code>CancelPendingLimitsOrder</code> to clean up, or <code>None</code>.</p> <pre><code>from replaybt import CancelPendingLimitsOrder\n\nclass FlipStrategy(Strategy):\n    def on_exit(self, fill, trade):\n        # Cancel any pending scale-in limit orders\n        if trade.reason == \"TAKE_PROFIT\":\n            return CancelPendingLimitsOrder()\n        return None\n</code></pre> <p>Arguments:</p> Arg Type Description <code>fill</code> <code>Fill</code> The exit fill <code>trade</code> <code>Trade</code> Completed trade with entry/exit times, PnL, reason <p>Returns: <code>Order</code>, <code>CancelPendingLimitsOrder</code>, or <code>None</code></p>"},{"location":"strategy/callbacks/#check_exits","title":"check_exits","text":"<p>Called before <code>on_bar()</code> on every bar where positions are open. Lets you implement custom exit logic (e.g., time-based exits, indicator-based exits).</p> <pre><code>class TimedExitStrategy(Strategy):\n    def check_exits(self, bar, positions):\n        exits = []\n        for i, pos in enumerate(positions):\n            # Close after 100 bars\n            hours_held = (bar.timestamp - pos.entry_time).total_seconds() / 3600\n            if hours_held &gt; 100:\n                exits.append((i, bar.close, \"TIME_EXIT\"))\n        return exits\n</code></pre> <p>Return format: list of tuples:</p> <pre><code># Full close:\n(position_index, exit_price, reason_string)\n\n# Partial close:\n(position_index, exit_price, reason_string, close_fraction)\n# close_fraction: 0.5 = close 50% of position\n</code></pre> <p>Note</p> <p>If <code>check_exits()</code> returns any exits, <code>on_bar()</code> is skipped for that bar (same behavior as engine-level SL/TP exits).</p>"},{"location":"strategy/callbacks/#warmup","title":"Warmup","text":"<p>Indicators need a warmup period before producing valid values. During warmup, <code>indicators.get(\"name\")</code> returns <code>None</code>.</p> <pre><code>def on_bar(self, bar, indicators, positions):\n    ema = indicators.get(\"ema_fast\")\n    if ema is None:\n        return None  # still warming up\n    # ... rest of logic\n</code></pre> <p>The number of warmup bars depends on the indicator and its period. For an EMA with period 35 on 30m timeframe, you need at least <code>35 * 30 = 1,050</code> 1m bars before it's ready.</p>"},{"location":"strategy/custom-exits/","title":"Custom Exits","text":"<p>Beyond basic SL/TP, replaybt supports breakeven stops, trailing stops, partial take profit, and strategy-driven exits.</p>"},{"location":"strategy/custom-exits/#breakeven-stop","title":"Breakeven Stop","text":"<p>Move the stop loss to lock in a small profit once the position reaches a threshold:</p> <pre><code>MarketOrder(\n    side=Side.LONG,\n    take_profit_pct=0.06,\n    stop_loss_pct=0.03,\n    breakeven_trigger_pct=0.02,   # activate at +2%\n    breakeven_lock_pct=0.005,     # move SL to +0.5%\n)\n</code></pre> <p>When price reaches +1.5% from entry, the stop loss moves to entry + 0.5%. If price reverses, you exit with a small profit instead of a full loss.</p>"},{"location":"strategy/custom-exits/#trailing-stop","title":"Trailing Stop","text":"<p>A stop that follows price as it moves in your favor:</p> <pre><code>MarketOrder(\n    side=Side.LONG,\n    trailing_stop_pct=0.02,              # trail 2% below peak\n    trailing_stop_activation_pct=0.03,   # activate after +3% profit\n)\n</code></pre> <p>The trailing stop activates once the position is +3% in profit. From that point, it trails 2% below the highest price seen. If price drops 2% from its peak, the position closes.</p> <p>You can use a trailing stop with or without a fixed TP/SL:</p> <pre><code># Trailing stop only (no fixed TP)\nMarketOrder(\n    side=Side.LONG,\n    stop_loss_pct=0.05,           # safety SL\n    trailing_stop_pct=0.02,\n    trailing_stop_activation_pct=0.01,\n)\n</code></pre>"},{"location":"strategy/custom-exits/#partial-take-profit","title":"Partial Take Profit","text":"<p>Close a fraction of the position at the first TP, then set a new TP for the remainder:</p> <pre><code>MarketOrder(\n    side=Side.LONG,\n    take_profit_pct=0.05,\n    stop_loss_pct=0.03,\n    partial_tp_pct=0.5,           # close 50% at TP\n    partial_tp_new_tp_pct=0.10,   # new TP at +10% for remainder\n)\n</code></pre> <p>When the first TP is hit: 1. 50% of the position closes at the TP level 2. The remaining 50% gets a new TP at +10% from entry 3. The stop loss stays the same</p>"},{"location":"strategy/custom-exits/#strategy-driven-exits-check_exits","title":"Strategy-Driven Exits (check_exits)","text":"<p>For exits based on indicators, time, or custom logic, implement <code>check_exits()</code>:</p> <pre><code>class RSIExitStrategy(Strategy):\n    def check_exits(self, bar, positions):\n        exits = []\n        for i, pos in enumerate(positions):\n            # Exit long when RSI &gt; 70\n            rsi = self._current_rsi  # stored from on_bar\n            if pos.is_long and rsi and rsi &gt; 70:\n                exits.append((i, bar.close, \"RSI_OVERBOUGHT\"))\n        return exits\n\n    def on_bar(self, bar, indicators, positions):\n        self._current_rsi = indicators.get(\"rsi\")\n        # ... entry logic ...\n</code></pre>"},{"location":"strategy/custom-exits/#partial-close-via-check_exits","title":"Partial Close via check_exits","text":"<p>Return a 4-tuple to close a fraction:</p> <pre><code>def check_exits(self, bar, positions):\n    exits = []\n    for i, pos in enumerate(positions):\n        pnl_pct = (bar.close - pos.entry_price) / pos.entry_price\n        if pos.is_long and pnl_pct &gt; 0.03:\n            # Close 50% at current price\n            exits.append((i, bar.close, \"PARTIAL_TAKE\", 0.5))\n    return exits\n</code></pre>"},{"location":"strategy/custom-exits/#post-exit-re-entry-on_exit","title":"Post-Exit Re-Entry (on_exit)","text":"<p>Use <code>on_exit()</code> to immediately enter a new position after an exit:</p> <pre><code>class FlipStrategy(Strategy):\n    def on_exit(self, fill, trade):\n        # After TP, flip direction if conditions are met\n        if trade.reason == \"TAKE_PROFIT\":\n            opposite = Side.SHORT if trade.side == Side.LONG else Side.LONG\n            return MarketOrder(\n                side=opposite,\n                take_profit_pct=0.05,\n                stop_loss_pct=0.03,\n            )\n        return None\n</code></pre>"},{"location":"strategy/custom-exits/#canceling-pending-orders-on-exit","title":"Canceling Pending Orders on Exit","text":"<p>When a position closes, any pending limit orders (e.g., scale-in) may still be active. Cancel them with <code>CancelPendingLimitsOrder</code>:</p> <pre><code>from replaybt import CancelPendingLimitsOrder\n\nclass CleanupStrategy(Strategy):\n    def on_exit(self, fill, trade):\n        # Cancel pending scale-in limit orders\n        return CancelPendingLimitsOrder()\n</code></pre>"},{"location":"strategy/custom-exits/#combining-exit-types","title":"Combining Exit Types","text":"<p>All exit types can be combined on a single order:</p> <pre><code>MarketOrder(\n    side=Side.LONG,\n    take_profit_pct=0.06,             # fixed TP\n    stop_loss_pct=0.03,              # fixed SL\n    breakeven_trigger_pct=0.02,      # breakeven at +2%\n    breakeven_lock_pct=0.005,        # lock at +0.5%\n    trailing_stop_pct=0.02,           # trail 2% below peak\n    trailing_stop_activation_pct=0.04, # activate at +4%\n    partial_tp_pct=0.5,               # close 50% at TP\n    partial_tp_new_tp_pct=0.12,       # remainder TP at +12%\n)\n</code></pre> <p>The engine evaluates exit conditions in priority order: gap check, SL, TP, breakeven activation, trailing stop update and check, partial TP.</p>"},{"location":"strategy/declarative/","title":"Declarative Strategy","text":"<p>Define a strategy entirely in JSON \u2014 no Python subclassing needed. Useful for AI agents, config-driven systems, or non-programmers.</p>"},{"location":"strategy/declarative/#quick-start","title":"Quick Start","text":"<pre><code>from replaybt import BacktestEngine, CSVProvider, DeclarativeStrategy\n\nstrategy = DeclarativeStrategy.from_json(\"trend_follower.json\")\nengine = BacktestEngine(\n    strategy=strategy,\n    data=CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n    config={\n        \"initial_equity\": 10_000,\n        \"indicators\": strategy.indicator_config(),\n    },\n)\nresults = engine.run()\n</code></pre>"},{"location":"strategy/declarative/#json-format","title":"JSON Format","text":"<pre><code>{\n  \"name\": \"TrendFollower\",\n  \"indicators\": {\n    \"ema_fast\": {\"type\": \"ema\", \"period\": 10, \"timeframe\": \"15m\", \"source\": \"close\"},\n    \"ema_slow\": {\"type\": \"ema\", \"period\": 50, \"timeframe\": \"15m\", \"source\": \"close\"},\n    \"ema_fast_1h\": {\"type\": \"ema\", \"period\": 20, \"timeframe\": \"1h\", \"source\": \"close\"},\n    \"ema_slow_1h\": {\"type\": \"ema\", \"period\": 50, \"timeframe\": \"1h\", \"source\": \"close\"}\n  },\n  \"entry\": {\n    \"long\": {\n      \"conditions\": [\n        {\"type\": \"crossover\", \"fast\": \"ema_fast\", \"slow\": \"ema_slow\"},\n        {\"type\": \"above\", \"left\": \"ema_fast_1h\", \"right\": \"ema_slow_1h\"}\n      ]\n    },\n    \"short\": {\n      \"conditions\": [\n        {\"type\": \"crossunder\", \"fast\": \"ema_fast\", \"slow\": \"ema_slow\"},\n        {\"type\": \"below\", \"left\": \"ema_fast_1h\", \"right\": \"ema_slow_1h\"}\n      ]\n    }\n  },\n  \"exit\": {\n    \"take_profit_pct\": 0.06,\n    \"stop_loss_pct\": 0.03,\n    \"breakeven_trigger_pct\": 0.02,\n    \"breakeven_lock_pct\": 0.005\n  }\n}\n</code></pre>"},{"location":"strategy/declarative/#condition-types","title":"Condition Types","text":""},{"location":"strategy/declarative/#crossover-crossunder","title":"Crossover / Crossunder","text":"<p>Signal when one indicator crosses above/below another:</p> <pre><code>{\"type\": \"crossover\", \"fast\": \"ema_fast\", \"slow\": \"ema_slow\"}\n{\"type\": \"crossunder\", \"fast\": \"ema_fast\", \"slow\": \"ema_slow\"}\n</code></pre>"},{"location":"strategy/declarative/#comparison","title":"Comparison","text":"<p>Compare two indicator values:</p> <pre><code>{\"type\": \"above\", \"left\": \"ema_fast_1h\", \"right\": \"ema_slow_1h\"}\n{\"type\": \"below\", \"left\": \"ema_fast_1h\", \"right\": \"ema_slow_1h\"}\n</code></pre> <p>You can also compare against <code>bar.close</code>, <code>bar.open</code>, <code>bar.high</code>, <code>bar.low</code>:</p> <pre><code>{\"type\": \"above\", \"left\": \"ema_fast\", \"right\": \"bar.close\"}\n</code></pre>"},{"location":"strategy/declarative/#threshold","title":"Threshold","text":"<p>Compare an indicator against a fixed value:</p> <pre><code>{\"type\": \"above_threshold\", \"indicator\": \"rsi\", \"threshold\": 70}\n{\"type\": \"below_threshold\", \"indicator\": \"rsi\", \"threshold\": 30}\n{\"type\": \"crosses_above\", \"indicator\": \"rsi\", \"threshold\": 25}\n{\"type\": \"crosses_below\", \"indicator\": \"rsi\", \"threshold\": 75}\n</code></pre>"},{"location":"strategy/declarative/#exit-configuration","title":"Exit Configuration","text":"<pre><code>{\n  \"exit\": {\n    \"take_profit_pct\": 0.06,\n    \"stop_loss_pct\": 0.03,\n    \"breakeven_trigger_pct\": 0.02,\n    \"breakeven_lock_pct\": 0.005,\n    \"trailing_stop_pct\": 0.02,\n    \"trailing_stop_activation_pct\": 0.03,\n    \"partial_tp_pct\": 0.5,\n    \"partial_tp_new_tp_pct\": 0.12\n  }\n}\n</code></pre>"},{"location":"strategy/declarative/#loading-methods","title":"Loading Methods","text":"<pre><code># From JSON file\nstrategy = DeclarativeStrategy.from_json(\"config.json\")\n\n# From Python dict\nstrategy = DeclarativeStrategy.from_config({\n    \"name\": \"MyStrategy\",\n    \"indicators\": {...},\n    \"entry\": {...},\n    \"exit\": {...},\n})\n</code></pre>"},{"location":"strategy/declarative/#getting-indicator-config","title":"Getting Indicator Config","text":"<p><code>indicator_config()</code> returns the indicators dict in the format expected by the engine:</p> <pre><code>strategy = DeclarativeStrategy.from_json(\"config.json\")\nindicator_cfg = strategy.indicator_config()\n# {\"ema_fast\": {\"type\": \"ema\", \"period\": 15, ...}, ...}\n</code></pre> <p>Pass it to the engine config:</p> <pre><code>engine = BacktestEngine(\n    strategy=strategy,\n    data=data,\n    config={\"indicators\": strategy.indicator_config()},\n)\n</code></pre>"},{"location":"strategy/per-symbol-config/","title":"Per-Symbol Config","text":"<p><code>StrategyConfig</code> provides defaults with per-symbol overrides. Useful when the same strategy runs on multiple assets with different parameters.</p>"},{"location":"strategy/per-symbol-config/#quick-start","title":"Quick Start","text":"<pre><code>from replaybt import StrategyConfig\n\nconfig = StrategyConfig(\n    defaults={\n        \"ema_fast\": 10,\n        \"ema_slow\": 50,\n        \"tp\": 0.06,\n        \"sl\": 0.03,\n    },\n    overrides={\n        \"ETH\": {\"ema_fast\": 12, \"ema_slow\": 26, \"tp\": 0.08, \"sl\": 0.04},\n        \"BNB\": {\"ema_fast\": 8, \"tp\": 0.10},\n    },\n)\n</code></pre>"},{"location":"strategy/per-symbol-config/#accessing-values","title":"Accessing Values","text":"<pre><code># With symbol \u2014 checks overrides first, falls back to defaults\nconfig.get(\"tp\", symbol=\"ETH\")   # 0.08 (ETH override)\nconfig.get(\"tp\", symbol=\"SOL\")   # 0.06 (default \u2014 no SOL override)\n\n# Without symbol \u2014 always returns default\nconfig.get(\"tp\")  # 0.06\n\n# With fallback\nconfig.get(\"missing_key\", default=42)  # 42\n</code></pre>"},{"location":"strategy/per-symbol-config/#merged-config-for-a-symbol","title":"Merged Config for a Symbol","text":"<pre><code>merged = config.for_symbol(\"ETH\")\n# {\"ema_fast\": 12, \"ema_slow\": 26, \"tp\": 0.08, \"sl\": 0.04}\n\nmerged = config.for_symbol(\"SOL\")\n# {\"ema_fast\": 10, \"ema_slow\": 50, \"tp\": 0.06, \"sl\": 0.03}\n</code></pre>"},{"location":"strategy/per-symbol-config/#listing-symbols","title":"Listing Symbols","text":"<pre><code>config.symbols()  # [\"ETH\", \"BNB\"]\n</code></pre>"},{"location":"strategy/per-symbol-config/#using-in-a-strategy","title":"Using in a Strategy","text":"<pre><code>from replaybt import Strategy, StrategyConfig, MarketOrder, Side\n\nclass TrendFollower(Strategy):\n    def configure(self, config):\n        self._params = StrategyConfig(\n            defaults={\"tp\": 0.06, \"sl\": 0.03},\n            overrides={\n                \"ETH\": {\"tp\": 0.08, \"sl\": 0.04},\n                \"BNB\": {\"tp\": 0.10},\n            },\n        )\n        self._prev = {}\n\n    def on_bar(self, bar, indicators, positions):\n        sym = bar.symbol\n        tp = self._params.get(\"tp\", symbol=sym)\n        sl = self._params.get(\"sl\", symbol=sym)\n\n        # ... crossover logic ...\n\n        if not positions and signal:\n            return MarketOrder(\n                side=Side.LONG,\n                take_profit_pct=tp,\n                stop_loss_pct=sl,\n            )\n        return None\n</code></pre>"},{"location":"strategy/per-symbol-config/#with-multiassetengine","title":"With MultiAssetEngine","text":"<p><code>StrategyConfig</code> pairs naturally with <code>MultiAssetEngine</code> for multi-symbol backtests where each asset needs different parameters:</p> <pre><code>from replaybt import MultiAssetEngine, CSVProvider\n\nengine = MultiAssetEngine(\n    strategy=TrendFollower(),\n    assets={\n        \"ETH\": CSVProvider(\"ETH_1m.csv\", symbol_name=\"ETH\"),\n        \"SOL\": CSVProvider(\"SOL_1m.csv\", symbol_name=\"SOL\"),\n        \"BNB\": CSVProvider(\"BNB_1m.csv\", symbol_name=\"BNB\"),\n    },\n    config={\n        \"initial_equity\": 10_000,\n        \"indicators\": {\n            \"ema_fast\": {\"type\": \"ema\", \"period\": 15, \"source\": \"close\"},\n            \"ema_slow\": {\"type\": \"ema\", \"period\": 35, \"source\": \"close\"},\n        },\n        \"symbol_configs\": {\n            \"ETH\": {\n                \"indicators\": {\n                    \"ema_fast\": {\"type\": \"ema\", \"period\": 10, \"source\": \"close\"},\n                    \"ema_slow\": {\"type\": \"ema\", \"period\": 30, \"source\": \"close\"},\n                },\n            },\n        },\n    },\n)\n</code></pre>"}]}